{"ast":null,"code":"/**\n * Highcharts JS v11.2.0 (2023-10-30)\n *\n * 3D features for Highcharts JS\n *\n * License: www.highcharts.com/license\n */!function (t) {\n  \"object\" == typeof module && module.exports ? (t.default = t, module.exports = t) : \"function\" == typeof define && define.amd ? define(\"highcharts/highcharts-3d\", [\"highcharts\"], function (e) {\n    return t(e), t.Highcharts = e, t;\n  }) : t(\"undefined\" != typeof Highcharts ? Highcharts : void 0);\n}(function (t) {\n  \"use strict\";\n\n  var e = t ? t._modules : {};\n  function i(t, e, i, s) {\n    t.hasOwnProperty(e) || (t[e] = s.apply(null, i), \"function\" == typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: e,\n        module: t[e]\n      }\n    })));\n  }\n  i(e, \"Core/Math3D.js\", [e[\"Core/Globals.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        deg2rad: i\n      } = t,\n      {\n        pick: s\n      } = e;\n    function o(t, e, o, a) {\n      let n = e.options.chart.options3d,\n        l = s(a, !!o && e.inverted),\n        h = {\n          x: e.plotWidth / 2,\n          y: e.plotHeight / 2,\n          z: n.depth / 2,\n          vd: s(n.depth, 1) * s(n.viewDistance, 0)\n        },\n        p = e.scale3d || 1,\n        c = i * n.beta * (l ? -1 : 1),\n        d = i * n.alpha * (l ? -1 : 1),\n        x = {\n          cosA: Math.cos(d),\n          cosB: Math.cos(-c),\n          sinA: Math.sin(d),\n          sinB: Math.sin(-c)\n        };\n      return o || (h.x += e.plotLeft, h.y += e.plotTop), t.map(function (t) {\n        var e, i, s;\n        let o = (e = (l ? t.y : t.x) - h.x, i = (l ? t.x : t.y) - h.y, s = (t.z || 0) - h.z, {\n            x: x.cosB * e - x.sinB * s,\n            y: -x.sinA * x.sinB * e + x.cosA * i - x.cosB * x.sinA * s,\n            z: x.cosA * x.sinB * e + x.sinA * i + x.cosA * x.cosB * s\n          }),\n          a = r(o, h, h.vd);\n        return a.x = a.x * p + h.x, a.y = a.y * p + h.y, a.z = o.z * p + h.z, {\n          x: l ? a.y : a.x,\n          y: l ? a.x : a.y,\n          z: a.z\n        };\n      });\n    }\n    function r(t, e, i) {\n      let s = i > 0 && i < Number.POSITIVE_INFINITY ? i / (t.z + e.z + i) : 1;\n      return {\n        x: t.x * s,\n        y: t.y * s\n      };\n    }\n    function a(t) {\n      let e = 0,\n        i,\n        s;\n      for (i = 0; i < t.length; i++) s = (i + 1) % t.length, e += t[i].x * t[s].y - t[s].x * t[i].y;\n      return e / 2;\n    }\n    return {\n      perspective: o,\n      perspective3D: r,\n      pointCameraDistance: function (t, e) {\n        let i = e.options.chart.options3d,\n          o = {\n            x: e.plotWidth / 2,\n            y: e.plotHeight / 2,\n            z: s(i.depth, 1) * s(i.viewDistance, 0) + i.depth\n          },\n          r = Math.sqrt(Math.pow(o.x - s(t.plotX, t.x), 2) + Math.pow(o.y - s(t.plotY, t.y), 2) + Math.pow(o.z - s(t.plotZ, t.z), 2));\n        return r;\n      },\n      shapeArea: a,\n      shapeArea3D: function (t, e, i) {\n        return a(o(t, e, i));\n      }\n    };\n  }), i(e, \"Core/Chart/Chart3D.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Defaults.js\"], e[\"Core/Math3D.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    var o;\n    let {\n        parse: r\n      } = t,\n      {\n        defaultOptions: a\n      } = e,\n      {\n        perspective: n,\n        shapeArea3D: l\n      } = i,\n      {\n        addEvent: h,\n        isArray: p,\n        merge: c,\n        pick: d,\n        wrap: x\n      } = s;\n    return function (t) {\n      function e(t) {\n        this.is3d() && \"scatter\" === t.options.type && (t.options.type = \"scatter3d\");\n      }\n      function i() {\n        if (this.chart3d && this.is3d()) {\n          let t = this.renderer,\n            e = this.options.chart.options3d,\n            i = this.chart3d.get3dFrame(),\n            s = this.plotLeft,\n            o = this.plotLeft + this.plotWidth,\n            a = this.plotTop,\n            n = this.plotTop + this.plotHeight,\n            l = e.depth,\n            h = s - (i.left.visible ? i.left.size : 0),\n            p = o + (i.right.visible ? i.right.size : 0),\n            c = a - (i.top.visible ? i.top.size : 0),\n            d = n + (i.bottom.visible ? i.bottom.size : 0),\n            x = 0 - (i.front.visible ? i.front.size : 0),\n            y = l + (i.back.visible ? i.back.size : 0),\n            f = this.hasRendered ? \"animate\" : \"attr\";\n          this.chart3d.frame3d = i, this.frameShapes || (this.frameShapes = {\n            bottom: t.polyhedron().add(),\n            top: t.polyhedron().add(),\n            left: t.polyhedron().add(),\n            right: t.polyhedron().add(),\n            back: t.polyhedron().add(),\n            front: t.polyhedron().add()\n          }), this.frameShapes.bottom[f]({\n            class: \"highcharts-3d-frame highcharts-3d-frame-bottom\",\n            zIndex: i.bottom.frontFacing ? -1e3 : 1e3,\n            faces: [{\n              fill: r(i.bottom.color).brighten(.1).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: h,\n                y: d,\n                z: y\n              }],\n              enabled: i.bottom.visible\n            }, {\n              fill: r(i.bottom.color).brighten(.1).get(),\n              vertexes: [{\n                x: s,\n                y: n,\n                z: l\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }],\n              enabled: i.bottom.visible\n            }, {\n              fill: r(i.bottom.color).brighten(-.1).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }],\n              enabled: i.bottom.visible && !i.left.visible\n            }, {\n              fill: r(i.bottom.color).brighten(-.1).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }],\n              enabled: i.bottom.visible && !i.right.visible\n            }, {\n              fill: r(i.bottom.color).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }],\n              enabled: i.bottom.visible && !i.front.visible\n            }, {\n              fill: r(i.bottom.color).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }],\n              enabled: i.bottom.visible && !i.back.visible\n            }]\n          }), this.frameShapes.top[f]({\n            class: \"highcharts-3d-frame highcharts-3d-frame-top\",\n            zIndex: i.top.frontFacing ? -1e3 : 1e3,\n            faces: [{\n              fill: r(i.top.color).brighten(.1).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }],\n              enabled: i.top.visible\n            }, {\n              fill: r(i.top.color).brighten(.1).get(),\n              vertexes: [{\n                x: s,\n                y: a,\n                z: 0\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }],\n              enabled: i.top.visible\n            }, {\n              fill: r(i.top.color).brighten(-.1).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }],\n              enabled: i.top.visible && !i.left.visible\n            }, {\n              fill: r(i.top.color).brighten(-.1).get(),\n              vertexes: [{\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }],\n              enabled: i.top.visible && !i.right.visible\n            }, {\n              fill: r(i.top.color).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }],\n              enabled: i.top.visible && !i.front.visible\n            }, {\n              fill: r(i.top.color).get(),\n              vertexes: [{\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }],\n              enabled: i.top.visible && !i.back.visible\n            }]\n          }), this.frameShapes.left[f]({\n            class: \"highcharts-3d-frame highcharts-3d-frame-left\",\n            zIndex: i.left.frontFacing ? -1e3 : 1e3,\n            faces: [{\n              fill: r(i.left.color).brighten(.1).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }, {\n                x: h,\n                y: d,\n                z: y\n              }],\n              enabled: i.left.visible && !i.bottom.visible\n            }, {\n              fill: r(i.left.color).brighten(.1).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }],\n              enabled: i.left.visible && !i.top.visible\n            }, {\n              fill: r(i.left.color).brighten(-.1).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: h,\n                y: d,\n                z: x\n              }],\n              enabled: i.left.visible\n            }, {\n              fill: r(i.left.color).brighten(-.1).get(),\n              vertexes: [{\n                x: s,\n                y: a,\n                z: l\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }],\n              enabled: i.left.visible\n            }, {\n              fill: r(i.left.color).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }],\n              enabled: i.left.visible && !i.front.visible\n            }, {\n              fill: r(i.left.color).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }],\n              enabled: i.left.visible && !i.back.visible\n            }]\n          }), this.frameShapes.right[f]({\n            class: \"highcharts-3d-frame highcharts-3d-frame-right\",\n            zIndex: i.right.frontFacing ? -1e3 : 1e3,\n            faces: [{\n              fill: r(i.right.color).brighten(.1).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }, {\n                x: p,\n                y: d,\n                z: x\n              }],\n              enabled: i.right.visible && !i.bottom.visible\n            }, {\n              fill: r(i.right.color).brighten(.1).get(),\n              vertexes: [{\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }],\n              enabled: i.right.visible && !i.top.visible\n            }, {\n              fill: r(i.right.color).brighten(-.1).get(),\n              vertexes: [{\n                x: o,\n                y: a,\n                z: 0\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }],\n              enabled: i.right.visible\n            }, {\n              fill: r(i.right.color).brighten(-.1).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: p,\n                y: d,\n                z: y\n              }],\n              enabled: i.right.visible\n            }, {\n              fill: r(i.right.color).get(),\n              vertexes: [{\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }],\n              enabled: i.right.visible && !i.front.visible\n            }, {\n              fill: r(i.right.color).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }],\n              enabled: i.right.visible && !i.back.visible\n            }]\n          }), this.frameShapes.back[f]({\n            class: \"highcharts-3d-frame highcharts-3d-frame-back\",\n            zIndex: i.back.frontFacing ? -1e3 : 1e3,\n            faces: [{\n              fill: r(i.back.color).brighten(.1).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }],\n              enabled: i.back.visible && !i.bottom.visible\n            }, {\n              fill: r(i.back.color).brighten(.1).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }],\n              enabled: i.back.visible && !i.top.visible\n            }, {\n              fill: r(i.back.color).brighten(-.1).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: h,\n                y: c,\n                z: y\n              }, {\n                x: s,\n                y: a,\n                z: l\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }],\n              enabled: i.back.visible && !i.left.visible\n            }, {\n              fill: r(i.back.color).brighten(-.1).get(),\n              vertexes: [{\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }],\n              enabled: i.back.visible && !i.right.visible\n            }, {\n              fill: r(i.back.color).get(),\n              vertexes: [{\n                x: s,\n                y: a,\n                z: l\n              }, {\n                x: o,\n                y: a,\n                z: l\n              }, {\n                x: o,\n                y: n,\n                z: l\n              }, {\n                x: s,\n                y: n,\n                z: l\n              }],\n              enabled: i.back.visible\n            }, {\n              fill: r(i.back.color).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: y\n              }, {\n                x: p,\n                y: d,\n                z: y\n              }, {\n                x: p,\n                y: c,\n                z: y\n              }, {\n                x: h,\n                y: c,\n                z: y\n              }],\n              enabled: i.back.visible\n            }]\n          }), this.frameShapes.front[f]({\n            class: \"highcharts-3d-frame highcharts-3d-frame-front\",\n            zIndex: i.front.frontFacing ? -1e3 : 1e3,\n            faces: [{\n              fill: r(i.front.color).brighten(.1).get(),\n              vertexes: [{\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }],\n              enabled: i.front.visible && !i.bottom.visible\n            }, {\n              fill: r(i.front.color).brighten(.1).get(),\n              vertexes: [{\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }],\n              enabled: i.front.visible && !i.top.visible\n            }, {\n              fill: r(i.front.color).brighten(-.1).get(),\n              vertexes: [{\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }],\n              enabled: i.front.visible && !i.left.visible\n            }, {\n              fill: r(i.front.color).brighten(-.1).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: p,\n                y: c,\n                z: x\n              }, {\n                x: o,\n                y: a,\n                z: 0\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }],\n              enabled: i.front.visible && !i.right.visible\n            }, {\n              fill: r(i.front.color).get(),\n              vertexes: [{\n                x: o,\n                y: a,\n                z: 0\n              }, {\n                x: s,\n                y: a,\n                z: 0\n              }, {\n                x: s,\n                y: n,\n                z: 0\n              }, {\n                x: o,\n                y: n,\n                z: 0\n              }],\n              enabled: i.front.visible\n            }, {\n              fill: r(i.front.color).get(),\n              vertexes: [{\n                x: p,\n                y: d,\n                z: x\n              }, {\n                x: h,\n                y: d,\n                z: x\n              }, {\n                x: h,\n                y: c,\n                z: x\n              }, {\n                x: p,\n                y: c,\n                z: x\n              }],\n              enabled: i.front.visible\n            }]\n          });\n        }\n      }\n      function s() {\n        this.styledMode && [{\n          name: \"darker\",\n          slope: .6\n        }, {\n          name: \"brighter\",\n          slope: 1.4\n        }].forEach(function (t) {\n          this.renderer.definition({\n            tagName: \"filter\",\n            attributes: {\n              id: \"highcharts-\" + t.name\n            },\n            children: [{\n              tagName: \"feComponentTransfer\",\n              children: [{\n                tagName: \"feFuncR\",\n                attributes: {\n                  type: \"linear\",\n                  slope: t.slope\n                }\n              }, {\n                tagName: \"feFuncG\",\n                attributes: {\n                  type: \"linear\",\n                  slope: t.slope\n                }\n              }, {\n                tagName: \"feFuncB\",\n                attributes: {\n                  type: \"linear\",\n                  slope: t.slope\n                }\n              }]\n            }]\n          });\n        }, this);\n      }\n      function o() {\n        let t = this.options;\n        this.is3d() && (t.series || []).forEach(function (e) {\n          let i = e.type || t.chart.type || t.chart.defaultSeriesType;\n          \"scatter\" === i && (e.type = \"scatter3d\");\n        });\n      }\n      function y() {\n        let t = this.options.chart.options3d;\n        if (this.chart3d && this.is3d()) {\n          t && (t.alpha = t.alpha % 360 + (t.alpha >= 0 ? 0 : 360), t.beta = t.beta % 360 + (t.beta >= 0 ? 0 : 360));\n          let e = this.inverted,\n            i = this.clipBox,\n            s = this.margin;\n          i[e ? \"y\" : \"x\"] = -(s[3] || 0), i[e ? \"x\" : \"y\"] = -(s[0] || 0), i[e ? \"height\" : \"width\"] = this.chartWidth + (s[3] || 0) + (s[1] || 0), i[e ? \"width\" : \"height\"] = this.chartHeight + (s[0] || 0) + (s[2] || 0), this.scale3d = 1, !0 === t.fitToPlot && (this.scale3d = this.chart3d.getScale(t.depth)), this.chart3d.frame3d = this.chart3d.get3dFrame();\n        }\n      }\n      function f() {\n        this.is3d() && (this.isDirtyBox = !0);\n      }\n      function u() {\n        this.chart3d && this.is3d() && (this.chart3d.frame3d = this.chart3d.get3dFrame());\n      }\n      function z() {\n        this.chart3d || (this.chart3d = new v(this));\n      }\n      function b(t) {\n        return this.is3d() || t.apply(this, [].slice.call(arguments, 1));\n      }\n      function g(t) {\n        let e,\n          i = this.series.length;\n        if (this.is3d()) for (; i--;) (e = this.series[i]).translate(), e.render();else t.call(this);\n      }\n      function m(t) {\n        t.apply(this, [].slice.call(arguments, 1)), this.is3d() && (this.container.className += \" highcharts-3d-chart\");\n      }\n      t.defaultOptions = {\n        chart: {\n          options3d: {\n            enabled: !1,\n            alpha: 0,\n            beta: 0,\n            depth: 100,\n            fitToPlot: !0,\n            viewDistance: 25,\n            axisLabelPosition: null,\n            frame: {\n              visible: \"default\",\n              size: 1,\n              bottom: {},\n              top: {},\n              left: {},\n              right: {},\n              back: {},\n              front: {}\n            }\n          }\n        }\n      }, t.compose = function (r, n) {\n        let l = r.prototype,\n          d = n.prototype;\n        l.is3d = function () {\n          return !!(this.options.chart.options3d && this.options.chart.options3d.enabled);\n        }, l.propsRequireDirtyBox.push(\"chart.options3d\"), l.propsRequireUpdateSeries.push(\"chart.options3d\"), d.matrixSetter = function () {\n          let t;\n          if (this.pos < 1 && (p(this.start) || p(this.end))) {\n            let e = this.start || [1, 0, 0, 1, 0, 0],\n              i = this.end || [1, 0, 0, 1, 0, 0];\n            t = [];\n            for (let s = 0; s < 6; s++) t.push(this.pos * i[s] + (1 - this.pos) * e[s]);\n          } else t = this.end;\n          this.elem.attr(this.prop, t, null, !0);\n        }, c(!0, a, t.defaultOptions), h(r, \"init\", z), h(r, \"addSeries\", e), h(r, \"afterDrawChartBox\", i), h(r, \"afterGetContainer\", s), h(r, \"afterInit\", o), h(r, \"afterSetChartSize\", y), h(r, \"beforeRedraw\", f), h(r, \"beforeRender\", u), x(l, \"isInsidePlot\", b), x(l, \"renderSeries\", g), x(l, \"setClassName\", m);\n      };\n      class v {\n        constructor(t) {\n          this.frame3d = void 0, this.chart = t;\n        }\n        get3dFrame() {\n          let t = this.chart,\n            e = t.options.chart.options3d,\n            i = e.frame,\n            s = t.plotLeft,\n            o = t.plotLeft + t.plotWidth,\n            r = t.plotTop,\n            a = t.plotTop + t.plotHeight,\n            h = e.depth,\n            p = function (e) {\n              let i = l(e, t);\n              return i > .5 ? 1 : i < -.5 ? -1 : 0;\n            },\n            c = p([{\n              x: s,\n              y: a,\n              z: h\n            }, {\n              x: o,\n              y: a,\n              z: h\n            }, {\n              x: o,\n              y: a,\n              z: 0\n            }, {\n              x: s,\n              y: a,\n              z: 0\n            }]),\n            x = p([{\n              x: s,\n              y: r,\n              z: 0\n            }, {\n              x: o,\n              y: r,\n              z: 0\n            }, {\n              x: o,\n              y: r,\n              z: h\n            }, {\n              x: s,\n              y: r,\n              z: h\n            }]),\n            y = p([{\n              x: s,\n              y: r,\n              z: 0\n            }, {\n              x: s,\n              y: r,\n              z: h\n            }, {\n              x: s,\n              y: a,\n              z: h\n            }, {\n              x: s,\n              y: a,\n              z: 0\n            }]),\n            f = p([{\n              x: o,\n              y: r,\n              z: h\n            }, {\n              x: o,\n              y: r,\n              z: 0\n            }, {\n              x: o,\n              y: a,\n              z: 0\n            }, {\n              x: o,\n              y: a,\n              z: h\n            }]),\n            u = p([{\n              x: s,\n              y: a,\n              z: 0\n            }, {\n              x: o,\n              y: a,\n              z: 0\n            }, {\n              x: o,\n              y: r,\n              z: 0\n            }, {\n              x: s,\n              y: r,\n              z: 0\n            }]),\n            z = p([{\n              x: s,\n              y: r,\n              z: h\n            }, {\n              x: o,\n              y: r,\n              z: h\n            }, {\n              x: o,\n              y: a,\n              z: h\n            }, {\n              x: s,\n              y: a,\n              z: h\n            }]),\n            b = !1,\n            g = !1,\n            m = !1,\n            v = !1;\n          [].concat(t.xAxis, t.yAxis, t.zAxis).forEach(function (t) {\n            t && (t.horiz ? t.opposite ? g = !0 : b = !0 : t.opposite ? v = !0 : m = !0);\n          });\n          let M = function (t, e, i) {\n              let s = [\"size\", \"color\", \"visible\"],\n                o = {};\n              for (let e = 0; e < s.length; e++) {\n                let i = s[e];\n                for (let e = 0; e < t.length; e++) if (\"object\" == typeof t[e]) {\n                  let s = t[e][i];\n                  if (null != s) {\n                    o[i] = s;\n                    break;\n                  }\n                }\n              }\n              let r = i;\n              return !0 === o.visible || !1 === o.visible ? r = o.visible : \"auto\" === o.visible && (r = e > 0), {\n                size: d(o.size, 1),\n                color: d(o.color, \"none\"),\n                frontFacing: e > 0,\n                visible: r\n              };\n            },\n            S = {\n              axes: {},\n              bottom: M([i.bottom, i.top, i], c, b),\n              top: M([i.top, i.bottom, i], x, g),\n              left: M([i.left, i.right, i.side, i], y, m),\n              right: M([i.right, i.left, i.side, i], f, v),\n              back: M([i.back, i.front, i], z, !0),\n              front: M([i.front, i.back, i], u, !1)\n            };\n          if (\"auto\" === e.axisLabelPosition) {\n            let e = function (t, e) {\n                return t.visible !== e.visible || t.visible && e.visible && t.frontFacing !== e.frontFacing;\n              },\n              i = [];\n            e(S.left, S.front) && i.push({\n              y: (r + a) / 2,\n              x: s,\n              z: 0,\n              xDir: {\n                x: 1,\n                y: 0,\n                z: 0\n              }\n            }), e(S.left, S.back) && i.push({\n              y: (r + a) / 2,\n              x: s,\n              z: h,\n              xDir: {\n                x: 0,\n                y: 0,\n                z: -1\n              }\n            }), e(S.right, S.front) && i.push({\n              y: (r + a) / 2,\n              x: o,\n              z: 0,\n              xDir: {\n                x: 0,\n                y: 0,\n                z: 1\n              }\n            }), e(S.right, S.back) && i.push({\n              y: (r + a) / 2,\n              x: o,\n              z: h,\n              xDir: {\n                x: -1,\n                y: 0,\n                z: 0\n              }\n            });\n            let l = [];\n            e(S.bottom, S.front) && l.push({\n              x: (s + o) / 2,\n              y: a,\n              z: 0,\n              xDir: {\n                x: 1,\n                y: 0,\n                z: 0\n              }\n            }), e(S.bottom, S.back) && l.push({\n              x: (s + o) / 2,\n              y: a,\n              z: h,\n              xDir: {\n                x: -1,\n                y: 0,\n                z: 0\n              }\n            });\n            let p = [];\n            e(S.top, S.front) && p.push({\n              x: (s + o) / 2,\n              y: r,\n              z: 0,\n              xDir: {\n                x: 1,\n                y: 0,\n                z: 0\n              }\n            }), e(S.top, S.back) && p.push({\n              x: (s + o) / 2,\n              y: r,\n              z: h,\n              xDir: {\n                x: -1,\n                y: 0,\n                z: 0\n              }\n            });\n            let c = [];\n            e(S.bottom, S.left) && c.push({\n              z: (0 + h) / 2,\n              y: a,\n              x: s,\n              xDir: {\n                x: 0,\n                y: 0,\n                z: -1\n              }\n            }), e(S.bottom, S.right) && c.push({\n              z: (0 + h) / 2,\n              y: a,\n              x: o,\n              xDir: {\n                x: 0,\n                y: 0,\n                z: 1\n              }\n            });\n            let d = [];\n            e(S.top, S.left) && d.push({\n              z: (0 + h) / 2,\n              y: r,\n              x: s,\n              xDir: {\n                x: 0,\n                y: 0,\n                z: -1\n              }\n            }), e(S.top, S.right) && d.push({\n              z: (0 + h) / 2,\n              y: r,\n              x: o,\n              xDir: {\n                x: 0,\n                y: 0,\n                z: 1\n              }\n            });\n            let x = function (e, i, s) {\n              if (0 === e.length) return null;\n              if (1 === e.length) return e[0];\n              let o = n(e, t, !1),\n                r = 0;\n              for (let t = 1; t < o.length; t++) s * o[t][i] > s * o[r][i] ? r = t : s * o[t][i] == s * o[r][i] && o[t].z < o[r].z && (r = t);\n              return e[r];\n            };\n            S.axes = {\n              y: {\n                left: x(i, \"x\", -1),\n                right: x(i, \"x\", 1)\n              },\n              x: {\n                top: x(p, \"y\", -1),\n                bottom: x(l, \"y\", 1)\n              },\n              z: {\n                top: x(d, \"y\", -1),\n                bottom: x(c, \"y\", 1)\n              }\n            };\n          } else S.axes = {\n            y: {\n              left: {\n                x: s,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              },\n              right: {\n                x: o,\n                z: 0,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                }\n              }\n            },\n            x: {\n              top: {\n                y: r,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              },\n              bottom: {\n                y: a,\n                z: 0,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              }\n            },\n            z: {\n              top: {\n                x: m ? o : s,\n                y: r,\n                xDir: m ? {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                } : {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              },\n              bottom: {\n                x: m ? o : s,\n                y: a,\n                xDir: m ? {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                } : {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              }\n            }\n          };\n          return S;\n        }\n        getScale(t) {\n          let e = this.chart,\n            i = e.plotLeft,\n            s = e.plotWidth + i,\n            o = e.plotTop,\n            r = e.plotHeight + o,\n            a = i + e.plotWidth / 2,\n            l = o + e.plotHeight / 2,\n            h = {\n              minX: Number.MAX_VALUE,\n              maxX: -Number.MAX_VALUE,\n              minY: Number.MAX_VALUE,\n              maxY: -Number.MAX_VALUE\n            },\n            p,\n            c = 1;\n          return p = [{\n            x: i,\n            y: o,\n            z: 0\n          }, {\n            x: i,\n            y: o,\n            z: t\n          }], [0, 1].forEach(function (t) {\n            p.push({\n              x: s,\n              y: p[t].y,\n              z: p[t].z\n            });\n          }), [0, 1, 2, 3].forEach(function (t) {\n            p.push({\n              x: p[t].x,\n              y: r,\n              z: p[t].z\n            });\n          }), (p = n(p, e, !1)).forEach(function (t) {\n            h.minX = Math.min(h.minX, t.x), h.maxX = Math.max(h.maxX, t.x), h.minY = Math.min(h.minY, t.y), h.maxY = Math.max(h.maxY, t.y);\n          }), i > h.minX && (c = Math.min(c, 1 - Math.abs((i + a) / (h.minX + a)) % 1)), s < h.maxX && (c = Math.min(c, (s - a) / (h.maxX - a))), o > h.minY && (c = h.minY < 0 ? Math.min(c, (o + l) / (-h.minY + o + l)) : Math.min(c, 1 - (o + l) / (h.minY + l) % 1)), r < h.maxY && (c = Math.min(c, Math.abs((r - l) / (h.maxY - l)))), c;\n        }\n      }\n      t.Additions = v;\n    }(o || (o = {})), o;\n  }), i(e, \"Series/Area3D/Area3DSeries.js\", [e[\"Core/Math3D.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        perspective: s\n      } = t,\n      {\n        seriesTypes: {\n          line: {\n            prototype: o\n          }\n        }\n      } = e,\n      {\n        wrap: r\n      } = i,\n      a = [];\n    function n(t) {\n      let e = t.apply(this, [].slice.call(arguments, 1));\n      if (!this.chart.is3d()) return e;\n      let i = o.getGraphPath,\n        r = this.options,\n        a = Math.round(this.yAxis.getThreshold(r.threshold)),\n        n = [];\n      if (this.rawPointsX) for (let t = 0; t < this.points.length; t++) n.push({\n        x: this.rawPointsX[t],\n        y: r.stacking ? this.points[t].yBottom : a,\n        z: this.zPadding\n      });\n      let l = this.chart.options.chart.options3d;\n      n = s(n, this.chart, !0).map(t => ({\n        plotX: t.x,\n        plotY: t.y,\n        plotZ: t.z\n      })), this.group && l && l.depth && l.beta && (this.markerGroup && (this.markerGroup.add(this.group), this.markerGroup.attr({\n        translateX: 0,\n        translateY: 0\n      })), this.group.attr({\n        zIndex: Math.max(1, l.beta > 270 || l.beta < 90 ? l.depth - Math.round(this.zPadding || 0) : Math.round(this.zPadding || 0))\n      })), n.reversed = !0;\n      let h = i.call(this, n, !0, !0);\n      if (h[0] && \"M\" === h[0][0] && (h[0] = [\"L\", h[0][1], h[0][2]]), this.areaPath) {\n        let t = this.areaPath.splice(0, this.areaPath.length / 2).concat(h);\n        t.xMap = this.areaPath.xMap, this.areaPath = t;\n      }\n      return e;\n    }\n    return {\n      compose: function (t) {\n        i.pushUnique(a, t) && r(t.prototype, \"getGraphPath\", n);\n      }\n    };\n  }), i(e, \"Core/Axis/Axis3DDefaults.js\", [], function () {\n    return {\n      labels: {\n        position3d: \"offset\",\n        skew3d: !1\n      },\n      title: {\n        position3d: null,\n        skew3d: null\n      }\n    };\n  }), i(e, \"Core/Axis/Tick3DComposition.js\", [e[\"Core/Utilities.js\"]], function (t) {\n    let {\n        addEvent: e,\n        extend: i,\n        wrap: s\n      } = t,\n      o = [];\n    function r(t) {\n      let e = this.axis.axis3D;\n      e && i(t.pos, e.fix3dPosition(t.pos));\n    }\n    function a(t) {\n      let e = this.axis.axis3D,\n        i = t.apply(this, [].slice.call(arguments, 1));\n      if (e) {\n        let t = i[0],\n          s = i[1];\n        if (\"M\" === t[0] && \"L\" === s[0]) {\n          let i = [e.fix3dPosition({\n            x: t[1],\n            y: t[2],\n            z: 0\n          }), e.fix3dPosition({\n            x: s[1],\n            y: s[2],\n            z: 0\n          })];\n          return this.axis.chart.renderer.toLineSegments(i);\n        }\n      }\n      return i;\n    }\n    return {\n      compose: function (i) {\n        t.pushUnique(o, i) && (e(i, \"afterGetLabelPosition\", r), s(i.prototype, \"getMarkPath\", a));\n      }\n    };\n  }), i(e, \"Core/Axis/Axis3DComposition.js\", [e[\"Core/Axis/Axis3DDefaults.js\"], e[\"Core/Globals.js\"], e[\"Core/Math3D.js\"], e[\"Core/Axis/Tick3DComposition.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o) {\n    let {\n        deg2rad: r\n      } = e,\n      {\n        perspective: a,\n        perspective3D: n,\n        shapeArea: l\n      } = i,\n      {\n        addEvent: h,\n        merge: p,\n        pick: c,\n        wrap: d\n      } = o,\n      x = [];\n    function y() {\n      let t = this.chart,\n        e = this.options;\n      t.is3d && t.is3d() && \"colorAxis\" !== this.coll && (e.tickWidth = c(e.tickWidth, 0), e.gridLineWidth = c(e.gridLineWidth, 1));\n    }\n    function f(t) {\n      this.chart.is3d() && \"colorAxis\" !== this.coll && t.point && (t.point.crosshairPos = this.isXAxis ? t.point.axisXpos : this.len - t.point.axisYpos);\n    }\n    function u() {\n      this.axis3D || (this.axis3D = new M(this));\n    }\n    function z(t) {\n      return this.chart.is3d() && \"colorAxis\" !== this.coll ? [] : t.apply(this, [].slice.call(arguments, 1));\n    }\n    function b(t) {\n      if (!this.chart.is3d() || \"colorAxis\" === this.coll) return t.apply(this, [].slice.call(arguments, 1));\n      let e = arguments,\n        i = e[1],\n        s = e[2],\n        o = [],\n        r = this.getPlotLinePath({\n          value: i\n        }),\n        a = this.getPlotLinePath({\n          value: s\n        });\n      if (r && a) for (let t = 0; t < r.length; t += 2) {\n        let e = r[t],\n          i = r[t + 1],\n          s = a[t],\n          n = a[t + 1];\n        \"M\" === e[0] && \"L\" === i[0] && \"M\" === s[0] && \"L\" === n[0] && o.push(e, i, n, [\"L\", s[1], s[2]], [\"Z\"]);\n      }\n      return o;\n    }\n    function g(t) {\n      let e = this.axis3D,\n        i = this.chart,\n        s = t.apply(this, [].slice.call(arguments, 1));\n      if (\"colorAxis\" === this.coll || !i.chart3d || !i.is3d() || null === s) return s;\n      let o = i.options.chart.options3d,\n        r = this.isZAxis ? i.plotWidth : o.depth,\n        n = i.chart3d.frame3d,\n        l = s[0],\n        h = s[1],\n        p,\n        c = [];\n      return \"M\" === l[0] && \"L\" === h[0] && (p = [e.swapZ({\n        x: l[1],\n        y: l[2],\n        z: 0\n      }), e.swapZ({\n        x: l[1],\n        y: l[2],\n        z: r\n      }), e.swapZ({\n        x: h[1],\n        y: h[2],\n        z: 0\n      }), e.swapZ({\n        x: h[1],\n        y: h[2],\n        z: r\n      })], this.horiz ? (this.isZAxis ? (n.left.visible && c.push(p[0], p[2]), n.right.visible && c.push(p[1], p[3])) : (n.front.visible && c.push(p[0], p[2]), n.back.visible && c.push(p[1], p[3])), n.top.visible && c.push(p[0], p[1]), n.bottom.visible && c.push(p[2], p[3])) : (n.front.visible && c.push(p[0], p[2]), n.back.visible && c.push(p[1], p[3]), n.left.visible && c.push(p[0], p[1]), n.right.visible && c.push(p[2], p[3])), c = a(c, this.chart, !1)), i.renderer.toLineSegments(c);\n    }\n    function m(t, e) {\n      let i = this.chart,\n        s = this.ticks,\n        o = this.gridGroup;\n      if (this.categories && i.frameShapes && i.is3d() && o && e && e.label) {\n        let t, r, a;\n        let l = o.element.childNodes[0].getBBox(),\n          h = i.frameShapes.left.getBBox(),\n          p = i.options.chart.options3d,\n          d = {\n            x: i.plotWidth / 2,\n            y: i.plotHeight / 2,\n            z: p.depth / 2,\n            vd: c(p.depth, 1) * c(p.viewDistance, 0)\n          },\n          x = e.pos,\n          y = s[x - 1],\n          f = s[x + 1];\n        return 0 !== x && y && y.label && y.label.xy && (r = n({\n          x: y.label.xy.x,\n          y: y.label.xy.y,\n          z: null\n        }, d, d.vd)), f && f.label && f.label.xy && (a = n({\n          x: f.label.xy.x,\n          y: f.label.xy.y,\n          z: null\n        }, d, d.vd)), t = n(t = {\n          x: e.label.xy.x,\n          y: e.label.xy.y,\n          z: null\n        }, d, d.vd), Math.abs(r ? t.x - r.x : a ? a.x - t.x : l.x - h.x);\n      }\n      return t.apply(this, [].slice.call(arguments, 1));\n    }\n    function v(t) {\n      let e = t.apply(this, [].slice.call(arguments, 1));\n      return this.axis3D ? this.axis3D.fix3dPosition(e, !0) : e;\n    }\n    class M {\n      static compose(e, i) {\n        if (s.compose(i), o.pushUnique(x, e)) {\n          p(!0, e.defaultOptions, t), e.keepProps.push(\"axis3D\"), h(e, \"init\", u), h(e, \"afterSetOptions\", y), h(e, \"drawCrosshair\", f);\n          let i = e.prototype;\n          d(i, \"getLinePath\", z), d(i, \"getPlotBandPath\", b), d(i, \"getPlotLinePath\", g), d(i, \"getSlotWidth\", m), d(i, \"getTitlePosition\", v);\n        }\n      }\n      constructor(t) {\n        this.axis = t;\n      }\n      fix3dPosition(t, e) {\n        let i = this.axis,\n          s = i.chart;\n        if (\"colorAxis\" === i.coll || !s.chart3d || !s.is3d()) return t;\n        let o = r * s.options.chart.options3d.alpha,\n          n = r * s.options.chart.options3d.beta,\n          h = c(e && i.options.title.position3d, i.options.labels.position3d),\n          p = c(e && i.options.title.skew3d, i.options.labels.skew3d),\n          d = s.chart3d.frame3d,\n          x = s.plotLeft,\n          y = s.plotWidth + x,\n          f = s.plotTop,\n          u = s.plotHeight + f,\n          z = 0,\n          b = 0,\n          g,\n          m = {\n            x: 0,\n            y: 1,\n            z: 0\n          },\n          v = !1;\n        if (t = i.axis3D.swapZ({\n          x: t.x,\n          y: t.y,\n          z: 0\n        }), i.isZAxis) {\n          if (i.opposite) {\n            if (null === d.axes.z.top) return {};\n            b = t.y - f, t.x = d.axes.z.top.x, t.y = d.axes.z.top.y, g = d.axes.z.top.xDir, v = !d.top.frontFacing;\n          } else {\n            if (null === d.axes.z.bottom) return {};\n            b = t.y - u, t.x = d.axes.z.bottom.x, t.y = d.axes.z.bottom.y, g = d.axes.z.bottom.xDir, v = !d.bottom.frontFacing;\n          }\n        } else if (i.horiz) {\n          if (i.opposite) {\n            if (null === d.axes.x.top) return {};\n            b = t.y - f, t.y = d.axes.x.top.y, t.z = d.axes.x.top.z, g = d.axes.x.top.xDir, v = !d.top.frontFacing;\n          } else {\n            if (null === d.axes.x.bottom) return {};\n            b = t.y - u, t.y = d.axes.x.bottom.y, t.z = d.axes.x.bottom.z, g = d.axes.x.bottom.xDir, v = !d.bottom.frontFacing;\n          }\n        } else if (i.opposite) {\n          if (null === d.axes.y.right) return {};\n          z = t.x - y, t.x = d.axes.y.right.x, t.z = d.axes.y.right.z, g = {\n            x: (g = d.axes.y.right.xDir).z,\n            y: g.y,\n            z: -g.x\n          };\n        } else {\n          if (null === d.axes.y.left) return {};\n          z = t.x - x, t.x = d.axes.y.left.x, t.z = d.axes.y.left.z, g = d.axes.y.left.xDir;\n        }\n        if (\"chart\" === h) ;else if (\"flap\" === h) {\n          if (i.horiz) {\n            let t = Math.sin(o);\n            i.opposite && (t = -t), v && (t = -t), m = {\n              x: g.z * t,\n              y: Math.cos(o),\n              z: -g.x * t\n            };\n          } else g = {\n            x: Math.cos(n),\n            y: 0,\n            z: Math.sin(n)\n          };\n        } else if (\"ortho\" === h) {\n          if (i.horiz) {\n            let t = Math.cos(o),\n              e = {\n                x: Math.sin(n) * t,\n                y: -Math.sin(o),\n                z: -t * Math.cos(n)\n              },\n              i = 1 / Math.sqrt((m = {\n                x: g.y * e.z - g.z * e.y,\n                y: g.z * e.x - g.x * e.z,\n                z: g.x * e.y - g.y * e.x\n              }).x * m.x + m.y * m.y + m.z * m.z);\n            v && (i = -i), m = {\n              x: i * m.x,\n              y: i * m.y,\n              z: i * m.z\n            };\n          } else g = {\n            x: Math.cos(n),\n            y: 0,\n            z: Math.sin(n)\n          };\n        } else i.horiz ? m = {\n          x: Math.sin(n) * Math.sin(o),\n          y: Math.cos(o),\n          z: -Math.cos(n) * Math.sin(o)\n        } : g = {\n          x: Math.cos(n),\n          y: 0,\n          z: Math.sin(n)\n        };\n        t.x += z * g.x + b * m.x, t.y += z * g.y + b * m.y, t.z += z * g.z + b * m.z;\n        let M = a([t], i.chart)[0];\n        if (p) {\n          let e = 0 > l(a([t, {\n            x: t.x + g.x,\n            y: t.y + g.y,\n            z: t.z + g.z\n          }, {\n            x: t.x + m.x,\n            y: t.y + m.y,\n            z: t.z + m.z\n          }], i.chart));\n          e && (g = {\n            x: -g.x,\n            y: -g.y,\n            z: -g.z\n          });\n          let s = a([{\n            x: t.x,\n            y: t.y,\n            z: t.z\n          }, {\n            x: t.x + g.x,\n            y: t.y + g.y,\n            z: t.z + g.z\n          }, {\n            x: t.x + m.x,\n            y: t.y + m.y,\n            z: t.z + m.z\n          }], i.chart);\n          M.matrix = [s[1].x - s[0].x, s[1].y - s[0].y, s[2].x - s[0].x, s[2].y - s[0].y, M.x, M.y], M.matrix[4] -= M.x * M.matrix[0] + M.y * M.matrix[2], M.matrix[5] -= M.x * M.matrix[1] + M.y * M.matrix[3];\n        }\n        return M;\n      }\n      swapZ(t, e) {\n        let i = this.axis;\n        if (i.isZAxis) {\n          let s = e ? 0 : i.chart.plotLeft;\n          return {\n            x: s + t.z,\n            y: t.y,\n            z: t.x - s\n          };\n        }\n        return t;\n      }\n    }\n    return M;\n  }), i(e, \"Core/Series/Series3D.js\", [e[\"Core/Math3D.js\"], e[\"Core/Series/Series.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        perspective: s\n      } = t,\n      {\n        addEvent: o,\n        extend: r,\n        merge: a,\n        pick: n,\n        pushUnique: l,\n        isNumber: h\n      } = i,\n      p = [];\n    class c extends e {\n      static compose(t) {\n        l(p, t) && (o(t, \"afterTranslate\", function () {\n          this.chart.is3d() && this.translate3dPoints();\n        }), r(t.prototype, {\n          translate3dPoints: c.prototype.translate3dPoints\n        }));\n      }\n      translate3dPoints() {\n        let t, e, i, o;\n        let r = this.options,\n          a = this.chart,\n          l = n(this.zAxis, a.options.zAxis[0]),\n          p = [],\n          c = [],\n          d = r.stacking ? h(r.stack) ? r.stack : 0 : this.index || 0;\n        for (o = 0, this.zPadding = d * (r.depth || 0 + (r.groupZPadding || 1)); o < this.data.length; o++) t = this.data[o], l && l.translate ? (i = l.logarithmic && l.val2lin ? l.val2lin(t.z) : t.z, t.plotZ = l.translate(i), t.isInside = !!t.isInside && i >= l.min && i <= l.max) : t.plotZ = this.zPadding, t.axisXpos = t.plotX, t.axisYpos = t.plotY, t.axisZpos = t.plotZ, p.push({\n          x: t.plotX,\n          y: t.plotY,\n          z: t.plotZ\n        }), c.push(t.plotX || 0);\n        this.rawPointsX = c;\n        let x = s(p, a, !0);\n        for (o = 0; o < this.data.length; o++) t = this.data[o], e = x[o], t.plotX = e.x, t.plotY = e.y, t.plotZ = e.z;\n      }\n    }\n    return c.defaultOptions = a(e.defaultOptions), c;\n  }), i(e, \"Core/Renderer/SVG/SVGElement3D.js\", [e[\"Core/Color/Color.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i) {\n    let {\n        parse: s\n      } = t,\n      {\n        Element: o\n      } = e.getRendererType().prototype,\n      {\n        defined: r,\n        pick: a\n      } = i;\n    class n extends o {\n      constructor() {\n        super(...arguments), this.parts = [\"front\", \"top\", \"side\"], this.pathType = \"cuboid\";\n      }\n      initArgs(t) {\n        let e = this.renderer,\n          i = e[this.pathType + \"Path\"](t),\n          s = i.zIndexes;\n        for (let t of this.parts) {\n          let o = {\n            class: \"highcharts-3d-\" + t,\n            zIndex: s[t] || 0\n          };\n          e.styledMode && (\"top\" === t ? o.filter = \"url(#highcharts-brighter)\" : \"side\" === t && (o.filter = \"url(#highcharts-darker)\")), this[t] = e.path(i[t]).attr(o).add(this);\n        }\n        this.attr({\n          \"stroke-linejoin\": \"round\",\n          zIndex: s.group\n        }), this.forcedSides = i.forcedSides;\n      }\n      singleSetterForParts(t, e, i, s, o, r) {\n        let a = {},\n          n = [null, null, s || \"attr\", o, r],\n          l = i && i.zIndexes;\n        if (i) {\n          for (let e of (l && l.group && this.attr({\n            zIndex: l.group\n          }), Object.keys(i))) a[e] = {}, a[e][t] = i[e], l && (a[e].zIndex = i.zIndexes[e] || 0);\n          n[1] = a;\n        } else a[t] = e, n[0] = a;\n        return this.processParts.apply(this, n);\n      }\n      processParts(t, e, i, s, o) {\n        for (let r of this.parts) e && (t = a(e[r], !1)), !1 !== t && this[r][i](t, s, o);\n        return this;\n      }\n      destroy() {\n        return this.processParts(null, null, \"destroy\"), super.destroy();\n      }\n      attr(t, e, i, s) {\n        if (\"string\" == typeof t && void 0 !== e) {\n          let i = t;\n          (t = {})[i] = e;\n        }\n        return t.shapeArgs || r(t.x) ? this.singleSetterForParts(\"d\", null, this.renderer[this.pathType + \"Path\"](t.shapeArgs || t)) : super.attr(t, void 0, i, s);\n      }\n      animate(t, e, i) {\n        if (r(t.x) && r(t.y)) {\n          let s = this.renderer[this.pathType + \"Path\"](t),\n            o = s.forcedSides;\n          this.singleSetterForParts(\"d\", null, s, \"animate\", e, i), this.attr({\n            zIndex: s.zIndexes.group\n          }), o === this.forcedSides || (this.forcedSides = o, this.renderer.styledMode || this.fillSetter(this.fill));\n        } else super.animate(t, e, i);\n        return this;\n      }\n      fillSetter(t) {\n        return this.forcedSides = this.forcedSides || [], this.singleSetterForParts(\"fill\", null, {\n          front: t,\n          top: s(t).brighten(this.forcedSides.indexOf(\"top\") >= 0 ? 0 : .1).get(),\n          side: s(t).brighten(this.forcedSides.indexOf(\"side\") >= 0 ? 0 : -.1).get()\n        }), this.color = this.fill = t, this;\n      }\n    }\n    return n.types = {\n      base: n,\n      cuboid: n\n    }, n;\n  }), i(e, \"Core/Renderer/SVG/SVGRenderer3D.js\", [e[\"Core/Animation/AnimationUtilities.js\"], e[\"Core/Color/Color.js\"], e[\"Core/Globals.js\"], e[\"Core/Math3D.js\"], e[\"Core/Renderer/SVG/SVGElement3D.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r) {\n    var a;\n    let {\n        animObject: n\n      } = t,\n      {\n        parse: l\n      } = e,\n      {\n        charts: h,\n        deg2rad: p\n      } = i,\n      {\n        perspective: c,\n        shapeArea: d\n      } = s,\n      {\n        defined: x,\n        extend: y,\n        merge: f,\n        pick: u,\n        pushUnique: z\n      } = r,\n      b = [],\n      g = Math.cos,\n      m = Math.sin,\n      v = Math.PI,\n      M = 4 * (Math.sqrt(2) - 1) / 3 / (v / 2);\n    function S(t, e, i, s, o, r, a, n) {\n      let l = r - o,\n        h = [];\n      return r > o && r - o > Math.PI / 2 + 1e-4 ? h = (h = h.concat(S(t, e, i, s, o, o + Math.PI / 2, a, n))).concat(S(t, e, i, s, o + Math.PI / 2, r, a, n)) : r < o && o - r > Math.PI / 2 + 1e-4 ? h = (h = h.concat(S(t, e, i, s, o, o - Math.PI / 2, a, n))).concat(S(t, e, i, s, o - Math.PI / 2, r, a, n)) : [[\"C\", t + i * Math.cos(o) - i * M * l * Math.sin(o) + a, e + s * Math.sin(o) + s * M * l * Math.cos(o) + n, t + i * Math.cos(r) + i * M * l * Math.sin(r) + a, e + s * Math.sin(r) - s * M * l * Math.cos(r) + n, t + i * Math.cos(r) + a, e + s * Math.sin(r) + n]];\n    }\n    return function (t) {\n      function e(t, e) {\n        let i = [];\n        for (let e of t) i.push([\"L\", e.x, e.y]);\n        return t.length && (i[0][0] = \"M\", e && i.push([\"Z\"])), i;\n      }\n      function s(t) {\n        let e = [],\n          i = !0;\n        for (let s of t) e.push(i ? [\"M\", s.x, s.y] : [\"L\", s.x, s.y]), i = !i;\n        return e;\n      }\n      function r(t) {\n        let e = this,\n          i = e.Element.prototype,\n          s = e.createElement(\"path\");\n        return s.vertexes = [], s.insidePlotArea = !1, s.enabled = !0, s.attr = function (t) {\n          if (\"object\" == typeof t && (x(t.enabled) || x(t.vertexes) || x(t.insidePlotArea))) {\n            this.enabled = u(t.enabled, this.enabled), this.vertexes = u(t.vertexes, this.vertexes), this.insidePlotArea = u(t.insidePlotArea, this.insidePlotArea), delete t.enabled, delete t.vertexes, delete t.insidePlotArea;\n            let i = h[e.chartIndex],\n              s = c(this.vertexes, i, this.insidePlotArea),\n              o = e.toLinePath(s, !0),\n              r = d(s);\n            t.d = o, t.visibility = this.enabled && r > 0 ? \"inherit\" : \"hidden\";\n          }\n          return i.attr.apply(this, arguments);\n        }, s.animate = function (t) {\n          if (\"object\" == typeof t && (x(t.enabled) || x(t.vertexes) || x(t.insidePlotArea))) {\n            this.enabled = u(t.enabled, this.enabled), this.vertexes = u(t.vertexes, this.vertexes), this.insidePlotArea = u(t.insidePlotArea, this.insidePlotArea), delete t.enabled, delete t.vertexes, delete t.insidePlotArea;\n            let i = h[e.chartIndex],\n              s = c(this.vertexes, i, this.insidePlotArea),\n              o = e.toLinePath(s, !0),\n              r = d(s),\n              a = this.enabled && r > 0 ? \"visible\" : \"hidden\";\n            t.d = o, this.attr(\"visibility\", a);\n          }\n          return i.animate.apply(this, arguments);\n        }, s.attr(t);\n      }\n      function a(t) {\n        let e = this,\n          i = e.Element.prototype,\n          s = e.g(),\n          o = s.destroy;\n        return this.styledMode || s.attr({\n          \"stroke-linejoin\": \"round\"\n        }), s.faces = [], s.destroy = function () {\n          for (let t = 0; t < s.faces.length; t++) s.faces[t].destroy();\n          return o.call(this);\n        }, s.attr = function (t, o, r, a) {\n          if (\"object\" == typeof t && x(t.faces)) {\n            for (; s.faces.length > t.faces.length;) s.faces.pop().destroy();\n            for (; s.faces.length < t.faces.length;) s.faces.push(e.face3d().add(s));\n            for (let i = 0; i < t.faces.length; i++) e.styledMode && delete t.faces[i].fill, s.faces[i].attr(t.faces[i], null, r, a);\n            delete t.faces;\n          }\n          return i.attr.apply(this, arguments);\n        }, s.animate = function (t, o, r) {\n          if (t && t.faces) {\n            for (; s.faces.length > t.faces.length;) s.faces.pop().destroy();\n            for (; s.faces.length < t.faces.length;) s.faces.push(e.face3d().add(s));\n            for (let e = 0; e < t.faces.length; e++) s.faces[e].animate(t.faces[e], o, r);\n            delete t.faces;\n          }\n          return i.animate.apply(this, arguments);\n        }, s.attr(t);\n      }\n      function M(t, e) {\n        let i = new o.types[t]();\n        return i.init(this, \"g\"), i.initArgs(e), i;\n      }\n      function A(t) {\n        return this.element3d(\"cuboid\", t);\n      }\n      function P(t) {\n        let e = t.x || 0,\n          i = t.y || 0,\n          s = t.z || 0,\n          o = t.height || 0,\n          r = t.width || 0,\n          a = t.depth || 0,\n          n = h[this.chartIndex],\n          l = n.options.chart.options3d,\n          p = l.alpha,\n          x = [],\n          y,\n          f = 0,\n          u = [{\n            x: e,\n            y: i,\n            z: s\n          }, {\n            x: e + r,\n            y: i,\n            z: s\n          }, {\n            x: e + r,\n            y: i + o,\n            z: s\n          }, {\n            x: e,\n            y: i + o,\n            z: s\n          }, {\n            x: e,\n            y: i + o,\n            z: s + a\n          }, {\n            x: e + r,\n            y: i + o,\n            z: s + a\n          }, {\n            x: e + r,\n            y: i,\n            z: s + a\n          }, {\n            x: e,\n            y: i,\n            z: s + a\n          }];\n        u = c(u, n, t.insidePlotArea);\n        let z = t => 0 === o && t > 1 && t < 6 ? {\n            x: u[t].x,\n            y: u[t].y + 10,\n            z: u[t].z\n          } : u[0].x === u[7].x && t >= 4 ? {\n            x: u[t].x + 10,\n            y: u[t].y,\n            z: u[t].z\n          } : 0 === a && t < 2 || t > 5 ? {\n            x: u[t].x,\n            y: u[t].y,\n            z: u[t].z + 10\n          } : u[t],\n          b = t => u[t],\n          g = (t, e, i) => {\n            let s = t.map(b),\n              o = e.map(b),\n              r = t.map(z),\n              a = e.map(z),\n              n = [[], -1];\n            return 0 > d(s) ? n = [s, 0] : 0 > d(o) ? n = [o, 1] : i && (x.push(i), n = 0 > d(r) ? [s, 0] : 0 > d(a) ? [o, 1] : [s, 0]), n;\n          };\n        y = g([3, 2, 1, 0], [7, 6, 5, 4], \"front\");\n        let m = y[0],\n          v = y[1];\n        y = g([1, 6, 7, 0], [4, 5, 2, 3], \"top\");\n        let M = y[0],\n          S = y[1];\n        y = g([1, 2, 5, 6], [0, 7, 4, 3], \"side\");\n        let A = y[0],\n          P = y[1];\n        return 1 === P ? f += 1e6 * (n.plotWidth - e) : P || (f += 1e6 * e), f += 10 * (!S || p >= 0 && p <= 180 || p < 360 && p > 357.5 ? n.plotHeight - i : 10 + i), 1 === v ? f += 100 * s : v || (f += 100 * (1e3 - s)), {\n          front: this.toLinePath(m, !0),\n          top: this.toLinePath(M, !0),\n          side: this.toLinePath(A, !0),\n          zIndexes: {\n            group: Math.round(f)\n          },\n          forcedSides: x,\n          isFront: v,\n          isTop: S\n        };\n      }\n      function D(t) {\n        let e = this.g(),\n          s = this.Element.prototype,\n          o = [\"x\", \"y\", \"r\", \"innerR\", \"start\", \"end\", \"depth\"];\n        function r(t) {\n          let e = {},\n            i = !1,\n            s;\n          for (s in t = f(t)) -1 !== o.indexOf(s) && (e[s] = t[s], delete t[s], i = !0);\n          return !!i && [e, t];\n        }\n        for (let i of ((t = f(t)).alpha = (t.alpha || 0) * p, t.beta = (t.beta || 0) * p, e.top = this.path(), e.side1 = this.path(), e.side2 = this.path(), e.inn = this.path(), e.out = this.path(), e.onAdd = function () {\n          let t = e.parentGroup,\n            i = e.attr(\"class\");\n          for (let s of (e.top.add(e), [\"out\", \"inn\", \"side1\", \"side2\"])) e[s].attr({\n            class: i + \" highcharts-3d-side\"\n          }).add(t);\n        }, [\"addClass\", \"removeClass\"])) e[i] = function () {\n          let t = arguments;\n          for (let s of [\"top\", \"out\", \"inn\", \"side1\", \"side2\"]) e[s][i].apply(e[s], t);\n        };\n        for (let i of (e.setPaths = function (t) {\n          let i = e.renderer.arc3dPath(t),\n            s = 100 * i.zTop;\n          e.attribs = t, e.top.attr({\n            d: i.top,\n            zIndex: i.zTop\n          }), e.inn.attr({\n            d: i.inn,\n            zIndex: i.zInn\n          }), e.out.attr({\n            d: i.out,\n            zIndex: i.zOut\n          }), e.side1.attr({\n            d: i.side1,\n            zIndex: i.zSide1\n          }), e.side2.attr({\n            d: i.side2,\n            zIndex: i.zSide2\n          }), e.zIndex = s, e.attr({\n            zIndex: s\n          }), t.center && (e.top.setRadialReference(t.center), delete t.center);\n        }, e.setPaths(t), e.fillSetter = function (t) {\n          let e = l(t).brighten(-.1).get();\n          return this.fill = t, this.side1.attr({\n            fill: e\n          }), this.side2.attr({\n            fill: e\n          }), this.inn.attr({\n            fill: e\n          }), this.out.attr({\n            fill: e\n          }), this.top.attr({\n            fill: t\n          }), this;\n        }, [\"opacity\", \"translateX\", \"translateY\", \"visibility\"])) e[i + \"Setter\"] = function (t, i) {\n          for (let s of (e[i] = t, [\"out\", \"inn\", \"side1\", \"side2\", \"top\"])) e[s].attr(i, t);\n        };\n        return e.attr = function (t) {\n          let i, o;\n          return \"object\" == typeof t && (o = r(t)) && (i = o[0], arguments[0] = o[1], y(e.attribs, i), e.setPaths(e.attribs)), s.attr.apply(e, arguments);\n        }, e.animate = function (t, o, a) {\n          let l, h;\n          let p = this.attribs,\n            c = \"data-\" + Math.random().toString(26).substring(2, 9);\n          delete t.center, delete t.z, delete t.alpha, delete t.beta;\n          let d = n(u(o, this.renderer.globalAnimation));\n          return d.duration && (l = r(t), e[c] = 0, t[c] = 1, e[c + \"Setter\"] = i.noop, l && (h = l[0], d.step = function (t, e) {\n            let i = t => p[t] + (u(h[t], p[t]) - p[t]) * e.pos;\n            e.prop === c && e.elem.setPaths(f(p, {\n              x: i(\"x\"),\n              y: i(\"y\"),\n              r: i(\"r\"),\n              innerR: i(\"innerR\"),\n              start: i(\"start\"),\n              end: i(\"end\"),\n              depth: i(\"depth\")\n            }));\n          }), o = d), s.animate.call(this, t, o, a);\n        }, e.destroy = function () {\n          return this.top.destroy(), this.out.destroy(), this.inn.destroy(), this.side1.destroy(), this.side2.destroy(), s.destroy.call(this);\n        }, e.hide = function () {\n          this.top.hide(), this.out.hide(), this.inn.hide(), this.side1.hide(), this.side2.hide();\n        }, e.show = function (t) {\n          this.top.show(t), this.out.show(t), this.inn.show(t), this.side1.show(t), this.side2.show(t);\n        }, e;\n      }\n      function C(t) {\n        let e = t.x || 0,\n          i = t.y || 0,\n          s = t.start || 0,\n          o = (t.end || 0) - 1e-5,\n          r = t.r || 0,\n          a = t.innerR || 0,\n          n = t.depth || 0,\n          l = t.alpha || 0,\n          h = t.beta || 0,\n          p = Math.cos(s),\n          c = Math.sin(s),\n          d = Math.cos(o),\n          x = Math.sin(o),\n          y = r * Math.cos(h),\n          f = r * Math.cos(l),\n          u = a * Math.cos(h),\n          z = a * Math.cos(l),\n          b = n * Math.sin(h),\n          M = n * Math.sin(l),\n          A = [[\"M\", e + y * p, i + f * c]];\n        (A = A.concat(S(e, i, y, f, s, o, 0, 0))).push([\"L\", e + u * d, i + z * x]), (A = A.concat(S(e, i, u, z, o, s, 0, 0))).push([\"Z\"]);\n        let P = h > 0 ? Math.PI / 2 : 0,\n          D = l > 0 ? 0 : Math.PI / 2,\n          C = s > -P ? s : o > -P ? -P : s,\n          k = o < v - D ? o : s < v - D ? v - D : o,\n          j = 2 * v - D,\n          L = [[\"M\", e + y * g(C), i + f * m(C)]];\n        L = L.concat(S(e, i, y, f, C, k, 0, 0)), o > j && s < j ? (L.push([\"L\", e + y * g(k) + b, i + f * m(k) + M]), (L = L.concat(S(e, i, y, f, k, j, b, M))).push([\"L\", e + y * g(j), i + f * m(j)]), (L = L.concat(S(e, i, y, f, j, o, 0, 0))).push([\"L\", e + y * g(o) + b, i + f * m(o) + M]), (L = L.concat(S(e, i, y, f, o, j, b, M))).push([\"L\", e + y * g(j), i + f * m(j)]), L = L.concat(S(e, i, y, f, j, k, 0, 0))) : o > v - D && s < v - D && (L.push([\"L\", e + y * Math.cos(k) + b, i + f * Math.sin(k) + M]), (L = L.concat(S(e, i, y, f, k, o, b, M))).push([\"L\", e + y * Math.cos(o), i + f * Math.sin(o)]), L = L.concat(S(e, i, y, f, o, k, 0, 0))), L.push([\"L\", e + y * Math.cos(k) + b, i + f * Math.sin(k) + M]), (L = L.concat(S(e, i, y, f, k, C, b, M))).push([\"Z\"]);\n        let w = [[\"M\", e + u * p, i + z * c]];\n        (w = w.concat(S(e, i, u, z, s, o, 0, 0))).push([\"L\", e + u * Math.cos(o) + b, i + z * Math.sin(o) + M]), (w = w.concat(S(e, i, u, z, o, s, b, M))).push([\"Z\"]);\n        let I = [[\"M\", e + y * p, i + f * c], [\"L\", e + y * p + b, i + f * c + M], [\"L\", e + u * p + b, i + z * c + M], [\"L\", e + u * p, i + z * c], [\"Z\"]],\n          T = [[\"M\", e + y * d, i + f * x], [\"L\", e + y * d + b, i + f * x + M], [\"L\", e + u * d + b, i + z * x + M], [\"L\", e + u * d, i + z * x], [\"Z\"]],\n          X = Math.atan2(M, -b),\n          Y = Math.abs(o + X),\n          Z = Math.abs(s + X),\n          G = Math.abs((s + o) / 2 + X);\n        function R(t) {\n          return (t %= 2 * Math.PI) > Math.PI && (t = 2 * Math.PI - t), t;\n        }\n        Y = R(Y), Z = R(Z), G = R(G);\n        let F = 1e5 * G,\n          O = 1e5 * Z,\n          E = 1e5 * Y;\n        return {\n          top: A,\n          zTop: 1e5 * Math.PI + 1,\n          out: L,\n          zOut: Math.max(F, O, E),\n          inn: w,\n          zInn: Math.max(F, O, E),\n          side1: I,\n          zSide1: .99 * E,\n          side2: T,\n          zSide2: .99 * O\n        };\n      }\n      t.compose = function (t) {\n        z(b, t) && y(t.prototype, {\n          Element3D: o,\n          arc3d: D,\n          arc3dPath: C,\n          cuboid: A,\n          cuboidPath: P,\n          element3d: M,\n          face3d: r,\n          polyhedron: a,\n          toLinePath: e,\n          toLineSegments: s\n        });\n      };\n    }(a || (a = {})), a;\n  }), i(e, \"Core/Axis/ZAxis.js\", [e[\"Core/Axis/Axis.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        addEvent: i,\n        merge: s,\n        pick: o,\n        splat: r\n      } = e,\n      a = [];\n    function n(t) {\n      return new h(this, t);\n    }\n    function l() {\n      let t = this.options.zAxis = r(this.options.zAxis || {});\n      this.is3d() && (this.zAxis = [], t.forEach((t, e) => {\n        this.addZAxis(t).setScale();\n      }));\n    }\n    class h extends t {\n      constructor() {\n        super(...arguments), this.isZAxis = !0;\n      }\n      static compose(t) {\n        if (e.pushUnique(a, t)) {\n          i(t, \"afterGetAxes\", l);\n          let e = t.prototype;\n          e.addZAxis = n, e.collectionsWithInit.zAxis = [e.addZAxis], e.collectionsWithUpdate.push(\"zAxis\");\n        }\n      }\n      init(t, e) {\n        this.isZAxis = !0, super.init(t, e, \"zAxis\");\n      }\n      getSeriesExtremes() {\n        this.chart, this.hasVisibleSeries = !1, this.dataMin = this.dataMax = this.ignoreMinPadding = this.ignoreMaxPadding = void 0, this.stacking && this.stacking.buildStacks(), this.series.forEach(t => {\n          if (t.reserveSpace()) {\n            let e = t.options.threshold;\n            this.hasVisibleSeries = !0, this.positiveValuesOnly && e <= 0 && (e = void 0);\n            let i = t.zData;\n            i.length && (this.dataMin = Math.min(o(this.dataMin, i[0]), Math.min.apply(null, i)), this.dataMax = Math.max(o(this.dataMax, i[0]), Math.max.apply(null, i)));\n          }\n        });\n      }\n      setAxisSize() {\n        let t = this.chart;\n        super.setAxisSize(), this.width = this.len = t.options.chart.options3d && t.options.chart.options3d.depth || 0, this.right = t.chartWidth - this.width - this.left;\n      }\n      setOptions(t) {\n        t = s({\n          offset: 0,\n          lineWidth: 0\n        }, t), super.setOptions(t);\n      }\n    }\n    return h;\n  }), i(e, \"Series/Column3D/Column3DComposition.js\", [e[\"Core/Math3D.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        perspective: i\n      } = t,\n      {\n        addEvent: s,\n        extend: o,\n        pick: r,\n        pushUnique: a,\n        wrap: n\n      } = e,\n      l = [];\n    function h() {\n      let t = this.chart,\n        e = this.options,\n        s = e.depth,\n        r = e.stacking ? e.stack || 0 : this.index,\n        a = r * (s + (e.groupZPadding || 1)),\n        n = this.borderWidth % 2 ? .5 : 0,\n        l;\n      for (let r of (t.inverted && !this.yAxis.reversed && (n *= -1), !1 !== e.grouping && (a = 0), a += e.groupZPadding || 1, this.data)) if (r.outside3dPlot = null, null !== r.y) {\n        let e;\n        let h = o({\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n          }, r.shapeArgs || {}),\n          p = [[\"x\", \"width\"], [\"y\", \"height\"]],\n          c = r.tooltipPos;\n        for (let t of p) if ((e = h[t[0]] - n) < 0 && (h[t[1]] += h[t[0]] + n, h[t[0]] = -n, e = 0), e + h[t[1]] > this[t[0] + \"Axis\"].len && 0 !== h[t[1]] && (h[t[1]] = this[t[0] + \"Axis\"].len - h[t[0]]), 0 !== h[t[1]] && (h[t[0]] >= this[t[0] + \"Axis\"].len || h[t[0]] + h[t[1]] <= n)) {\n          for (let t in h) h[t] = \"y\" === t ? -9999 : 0;\n          r.outside3dPlot = !0;\n        }\n        if (\"roundedRect\" === r.shapeType && (r.shapeType = \"cuboid\"), r.shapeArgs = o(h, {\n          z: a,\n          depth: s,\n          insidePlotArea: !0\n        }), l = {\n          x: h.x + h.width / 2,\n          y: h.y,\n          z: a + s / 2\n        }, t.inverted && (l.x = h.height, l.y = r.clientX || 0), r.plot3d = i([l], t, !0, !1)[0], c) {\n          let e = i([{\n            x: c[0],\n            y: c[1],\n            z: a + s / 2\n          }], t, !0, !1)[0];\n          r.tooltipPos = [e.x, e.y];\n        }\n      }\n      this.z = a;\n    }\n    function p() {\n      if (this.chart.is3d()) {\n        let t = this.options,\n          e = t.grouping,\n          i = t.stacking,\n          s = this.yAxis.options.reversedStacks,\n          o = 0;\n        if (!(void 0 !== e && !e)) {\n          let e;\n          let a = function (t, e) {\n              let i = t.series,\n                s = {\n                  totalStacks: 0\n                },\n                o,\n                a = 1;\n              return i.forEach(function (t) {\n                s[o = r(t.options.stack, e ? 0 : i.length - 1 - t.index)] ? s[o].series.push(t) : (s[o] = {\n                  series: [t],\n                  position: a\n                }, a++);\n              }), s.totalStacks = a + 1, s;\n            }(this.chart, i),\n            n = t.stack || 0;\n          for (e = 0; e < a[n].series.length && a[n].series[e] !== this; e++);\n          o = 10 * (a.totalStacks - a[n].position) + (s ? e : -e), this.xAxis.reversed || (o = 10 * a.totalStacks - o);\n        }\n        t.depth = t.depth || 25, this.z = this.z || 0, t.zIndex = o;\n      }\n    }\n    function c(t, ...e) {\n      return this.series.chart.is3d() ? this.graphic && \"g\" !== this.graphic.element.nodeName : t.apply(this, e);\n    }\n    function d(t) {\n      if (this.chart.is3d()) {\n        let t = arguments,\n          e = t[1],\n          i = this.yAxis,\n          s = this.yAxis.reversed;\n        if (e) for (let t of this.data) null === t.y || (t.height = t.shapeArgs.height, t.shapey = t.shapeArgs.y, t.shapeArgs.height = 1, s || (t.stackY ? t.shapeArgs.y = t.plotY + i.translate(t.stackY) : t.shapeArgs.y = t.plotY + (t.negative ? -t.height : t.height)));else {\n          for (let t of this.data) null !== t.y && (t.shapeArgs.height = t.height, t.shapeArgs.y = t.shapey, t.graphic && t.graphic[t.outside3dPlot ? \"attr\" : \"animate\"](t.shapeArgs, this.options.animation));\n          this.drawDataLabels();\n        }\n      } else t.apply(this, [].slice.call(arguments, 1));\n    }\n    function x(t, e, i, s, o, r) {\n      return \"dataLabelsGroup\" !== e && \"markerGroup\" !== e && this.chart.is3d() && (this[e] && delete this[e], r && (this.chart.columnGroup || (this.chart.columnGroup = this.chart.renderer.g(\"columnGroup\").add(r)), this[e] = this.chart.columnGroup, this.chart.columnGroup.attr(this.getPlotBox()), this[e].survive = !0, \"group\" === e && (arguments[3] = \"visible\"))), t.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    function y(t) {\n      let e = t.apply(this, [].slice.call(arguments, 1));\n      return this.chart.is3d && this.chart.is3d() && (e.stroke = this.options.edgeColor || e.fill, e[\"stroke-width\"] = r(this.options.edgeWidth, 1)), e;\n    }\n    function f(t, e, i) {\n      let s = this.chart.is3d && this.chart.is3d();\n      s && (this.options.inactiveOtherPoints = !0), t.call(this, e, i), s && (this.options.inactiveOtherPoints = !1);\n    }\n    function u(t, e) {\n      if (this.chart.is3d()) for (let t of this.data) t.visible = t.options.visible = e = void 0 === e ? !r(this.visible, t.visible) : e, this.options.data[this.data.indexOf(t)] = t.options, t.graphic && t.graphic.attr({\n        visibility: e ? \"visible\" : \"hidden\"\n      });\n      t.apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n    function z(t) {\n      t.apply(this, [].slice.call(arguments, 1)), this.chart.is3d() && this.translate3dShapes();\n    }\n    function b(t, e, s, o, a) {\n      let n = this.chart;\n      if (o.outside3dPlot = e.outside3dPlot, n.is3d() && this.is(\"column\")) {\n        let t = this.options,\n          s = r(o.inside, !!this.options.stacking),\n          l = n.options.chart.options3d,\n          h = e.pointWidth / 2 || 0,\n          p = {\n            x: a.x + h,\n            y: a.y,\n            z: this.z + t.depth / 2\n          };\n        n.inverted && (s && (a.width = 0, p.x += e.shapeArgs.height / 2), l.alpha >= 90 && l.alpha <= 270 && (p.y += e.shapeArgs.width)), p = i([p], n, !0, !1)[0], a.x = p.x - h, a.y = e.outside3dPlot ? -9e9 : p.y;\n      }\n      t.apply(this, [].slice.call(arguments, 1));\n    }\n    function g(t) {\n      return !arguments[2].outside3dPlot && t.apply(this, [].slice.call(arguments, 1));\n    }\n    function m(t, e) {\n      let s = t.apply(this, [].slice.call(arguments, 1)),\n        o = this.axis.chart,\n        {\n          width: r\n        } = e;\n      if (o.is3d() && this.base) {\n        let t = +this.base.split(\",\")[0],\n          e = o.series[t],\n          a = o.options.chart.options3d;\n        if (e && \"column\" === e.type) {\n          let t = {\n            x: s.x + (o.inverted ? s.height : r / 2),\n            y: s.y,\n            z: e.options.depth / 2\n          };\n          o.inverted && (s.width = 0, a.alpha >= 90 && a.alpha <= 270 && (t.y += r)), t = i([t], o, !0, !1)[0], s.x = t.x - r / 2, s.y = t.y;\n        }\n      }\n      return s;\n    }\n    return {\n      compose: function (t, e) {\n        if (a(l, t)) {\n          let e = t.prototype;\n          n(e, \"alignDataLabel\", b), n(e, \"justifyDataLabel\", g);\n        }\n        if (a(l, e)) {\n          let t = e.prototype;\n          n(t, \"getStackBox\", m);\n        }\n        let {\n          column: i,\n          columnRange: o\n        } = t.types;\n        if (i && a(l, i)) {\n          let t = i.prototype,\n            e = t.pointClass.prototype;\n          t.translate3dPoints = () => void 0, t.translate3dShapes = h, s(t, \"afterInit\", p), n(e, \"hasNewShapeType\", c), n(t, \"animate\", d), n(t, \"plotGroup\", x), n(t, \"pointAttribs\", y), n(t, \"setState\", f), n(t, \"setVisible\", u), n(t, \"translate\", z);\n        }\n        if (o && a(l, o)) {\n          let t = o.prototype,\n            e = t.pointClass.prototype;\n          n(e, \"hasNewShapeType\", c), n(t, \"plotGroup\", x), n(t, \"pointAttribs\", y), n(t, \"setState\", f), n(t, \"setVisible\", u);\n        }\n      }\n    };\n  }), i(e, \"Series/Pie3D/Pie3DPoint.js\", [e[\"Core/Series/SeriesRegistry.js\"]], function (t) {\n    let {\n      pie: {\n        prototype: {\n          pointClass: e\n        }\n      }\n    } = t.seriesTypes;\n    return class extends e {\n      constructor() {\n        super(...arguments), this.series = void 0;\n      }\n      haloPath() {\n        return this.series?.chart.is3d() ? [] : super.haloPath.apply(this, arguments);\n      }\n    };\n  }), i(e, \"Series/Pie3D/Pie3DSeries.js\", [e[\"Core/Globals.js\"], e[\"Series/Pie3D/Pie3DPoint.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s) {\n    let {\n        deg2rad: o\n      } = t,\n      {\n        pie: r\n      } = i.seriesTypes,\n      {\n        extend: a,\n        pick: n,\n        pushUnique: l\n      } = s,\n      h = [];\n    class p extends r {\n      static compose(t) {\n        l(h, t) && (t.types.pie = p);\n      }\n      addPoint() {\n        super.addPoint.apply(this, arguments), this.chart.is3d() && this.update(this.userOptions, !0);\n      }\n      animate(t) {\n        if (this.chart.is3d()) {\n          let e = this.center,\n            i = this.group,\n            s = this.markerGroup,\n            o = this.options.animation,\n            r;\n          !0 === o && (o = {}), t ? (i.oldtranslateX = n(i.oldtranslateX, i.translateX), i.oldtranslateY = n(i.oldtranslateY, i.translateY), r = {\n            translateX: e[0],\n            translateY: e[1],\n            scaleX: .001,\n            scaleY: .001\n          }, i.attr(r), s && (s.attrSetters = i.attrSetters, s.attr(r))) : (r = {\n            translateX: i.oldtranslateX,\n            translateY: i.oldtranslateY,\n            scaleX: 1,\n            scaleY: 1\n          }, i.animate(r, o), s && s.animate(r, o));\n        } else super.animate.apply(this, arguments);\n      }\n      getDataLabelPosition(t, e) {\n        let i = super.getDataLabelPosition(t, e);\n        if (this.chart.is3d()) {\n          let e = this.chart.options.chart.options3d,\n            s = t.shapeArgs,\n            r = s.r,\n            a = (s.alpha || e?.alpha) * o,\n            n = (s.beta || e?.beta) * o,\n            l = (s.start + s.end) / 2,\n            h = i.connectorPosition,\n            p = -r * (1 - Math.cos(a)) * Math.sin(l),\n            c = r * (Math.cos(n) - 1) * Math.cos(l);\n          for (let t of [i?.natural, h.breakAt, h.touchingSliceAt]) t.x += c, t.y += p;\n        }\n        return i;\n      }\n      pointAttribs(t) {\n        let e = super.pointAttribs.apply(this, arguments),\n          i = this.options;\n        return this.chart.is3d() && !this.chart.styledMode && (e.stroke = i.edgeColor || t.color || this.color, e[\"stroke-width\"] = n(i.edgeWidth, 1)), e;\n      }\n      translate() {\n        if (super.translate.apply(this, arguments), !this.chart.is3d()) return;\n        let t = this.options,\n          e = t.depth || 0,\n          i = this.chart.options.chart.options3d,\n          s = i.alpha,\n          r = i.beta,\n          a = t.stacking ? (t.stack || 0) * e : this._i * e;\n        for (let i of (a += e / 2, !1 !== t.grouping && (a = 0), this.data)) {\n          let n = i.shapeArgs;\n          i.shapeType = \"arc3d\", n.z = a, n.depth = .75 * e, n.alpha = s, n.beta = r, n.center = this.center;\n          let l = (n.end + n.start) / 2;\n          i.slicedTranslation = {\n            translateX: Math.round(Math.cos(l) * t.slicedOffset * Math.cos(s * o)),\n            translateY: Math.round(Math.sin(l) * t.slicedOffset * Math.cos(s * o))\n          };\n        }\n      }\n      drawTracker() {\n        if (super.drawTracker.apply(this, arguments), this.chart.is3d()) {\n          for (let t of this.points) if (t.graphic) for (let e of [\"out\", \"inn\", \"side1\", \"side2\"]) t.graphic && (t.graphic[e].element.point = t);\n        }\n      }\n    }\n    return a(p.prototype, {\n      pointClass: e\n    }), p;\n  }), i(e, \"Series/Scatter3D/Scatter3DPoint.js\", [e[\"Series/Scatter/ScatterSeries.js\"], e[\"Core/Utilities.js\"]], function (t, e) {\n    let {\n        pointClass: i\n      } = t.prototype,\n      {\n        defined: s\n      } = e;\n    return class extends i {\n      constructor() {\n        super(...arguments), this.options = void 0, this.series = void 0;\n      }\n      applyOptions() {\n        return super.applyOptions.apply(this, arguments), s(this.z) || (this.z = 0), this;\n      }\n    };\n  }), i(e, \"Series/Scatter3D/Scatter3DSeriesDefaults.js\", [], function () {\n    return {\n      tooltip: {\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>\"\n      }\n    };\n  }), i(e, \"Series/Scatter3D/Scatter3DSeries.js\", [e[\"Core/Math3D.js\"], e[\"Series/Scatter3D/Scatter3DPoint.js\"], e[\"Series/Scatter3D/Scatter3DSeriesDefaults.js\"], e[\"Series/Scatter/ScatterSeries.js\"], e[\"Core/Series/SeriesRegistry.js\"], e[\"Core/Utilities.js\"]], function (t, e, i, s, o, r) {\n    let {\n        pointCameraDistance: a\n      } = t,\n      {\n        extend: n,\n        merge: l\n      } = r;\n    class h extends s {\n      constructor() {\n        super(...arguments), this.data = void 0, this.options = void 0, this.points = void 0;\n      }\n      pointAttribs(t) {\n        let e = super.pointAttribs.apply(this, arguments);\n        return this.chart.is3d() && t && (e.zIndex = a(t, this.chart)), e;\n      }\n    }\n    return h.defaultOptions = l(s.defaultOptions, i), n(h.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\", \"zAxis\"],\n      directTouch: !0,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      pointArrayMap: [\"x\", \"y\", \"z\"],\n      pointClass: e\n    }), o.registerSeriesType(\"scatter3d\", h), h;\n  }), i(e, \"masters/highcharts-3d.src.js\", [e[\"Core/Globals.js\"], e[\"Core/Chart/Chart3D.js\"], e[\"Series/Area3D/Area3DSeries.js\"], e[\"Core/Axis/Axis3DComposition.js\"], e[\"Core/Renderer/RendererRegistry.js\"], e[\"Core/Series/Series3D.js\"], e[\"Core/Axis/Stacking/StackItem.js\"], e[\"Core/Renderer/SVG/SVGRenderer3D.js\"], e[\"Core/Axis/ZAxis.js\"], e[\"Series/Column3D/Column3DComposition.js\"], e[\"Series/Pie3D/Pie3DSeries.js\"]], function (t, e, i, s, o, r, a, n, l, h, p) {\n    i.compose(t.seriesTypes.area), s.compose(t.Axis, t.Tick), e.compose(t.Chart, t.Fx), h.compose(t.Series, a), p.compose(t.Series), r.compose(t.Series), n.compose(o.getRendererType()), l.compose(t.Chart);\n  });\n});","map":{"version":3,"names":["t","module","exports","default","define","amd","e","Highcharts","_modules","i","s","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","path","deg2rad","pick","o","a","n","options","chart","options3d","l","inverted","h","x","plotWidth","y","plotHeight","z","depth","vd","viewDistance","p","scale3d","c","beta","d","alpha","cosA","Math","cos","cosB","sinA","sin","sinB","plotLeft","plotTop","map","r","Number","POSITIVE_INFINITY","length","perspective","perspective3D","pointCameraDistance","sqrt","pow","plotX","plotY","plotZ","shapeArea","shapeArea3D","parse","defaultOptions","addEvent","isArray","merge","wrap","is3d","type","chart3d","renderer","get3dFrame","left","visible","size","right","top","bottom","front","back","f","hasRendered","frame3d","frameShapes","polyhedron","add","class","zIndex","frontFacing","faces","fill","color","brighten","get","vertexes","enabled","styledMode","name","slope","forEach","definition","tagName","attributes","id","children","series","defaultSeriesType","clipBox","margin","chartWidth","chartHeight","fitToPlot","getScale","isDirtyBox","u","v","b","slice","call","arguments","g","translate","render","m","container","className","axisLabelPosition","frame","compose","prototype","propsRequireDirtyBox","push","propsRequireUpdateSeries","matrixSetter","pos","start","end","elem","attr","prop","constructor","faceOrientation","concat","xAxis","yAxis","zAxis","horiz","opposite","M","getFaceOptions","S","axes","side","isValidEdge","xDir","pickEdge","minX","MAX_VALUE","maxX","minY","maxY","min","max","abs","Additions","seriesTypes","line","getGraphPath","round","getThreshold","threshold","rawPointsX","points","stacking","yBottom","zPadding","group","markerGroup","translateX","translateY","reversed","areaPath","splice","xMap","pushUnique","labels","position3d","skew3d","title","extend","axis","axis3D","fix3dPosition","toLineSegments","coll","tickWidth","gridLineWidth","point","crosshairPos","isXAxis","axisXpos","len","axisYpos","getPlotLinePath","value","isZAxis","swapZ","ticks","gridGroup","categories","label","element","childNodes","getBBox","xy","keepProps","matrix","isNumber","translate3dPoints","stack","index","groupZPadding","data","logarithmic","val2lin","isInside","axisZpos","Element","getRendererType","defined","parts","pathType","initArgs","zIndexes","filter","forcedSides","singleSetterForParts","Object","keys","processParts","destroy","shapeArgs","animate","fillSetter","indexOf","types","base","cuboid","animObject","charts","PI","createElement","insidePlotArea","chartIndex","toLinePath","visibility","pop","face3d","init","A","element3d","P","height","width","pickShape","isFront","isTop","D","side1","side2","inn","out","onAdd","parentGroup","setPaths","arc3dPath","zTop","attribs","zInn","zOut","zSide1","zSide2","center","setRadialReference","random","toString","substring","globalAnimation","duration","noop","step","innerR","hide","show","C","k","j","L","w","I","T","X","atan2","Y","Z","G","R","F","O","E","Element3D","arc3d","cuboidPath","splat","addZAxis","setScale","collectionsWithInit","collectionsWithUpdate","getSeriesExtremes","hasVisibleSeries","dataMin","dataMax","ignoreMinPadding","ignoreMaxPadding","buildStacks","reserveSpace","positiveValuesOnly","zData","setAxisSize","setOptions","offset","lineWidth","borderWidth","grouping","outside3dPlot","tooltipPos","shapeType","clientX","plot3d","reversedStacks","totalStacks","position","graphic","nodeName","shapey","stackY","negative","animation","drawDataLabels","columnGroup","getPlotBox","survive","Array","stroke","edgeColor","edgeWidth","inactiveOtherPoints","translate3dShapes","is","inside","pointWidth","split","column","columnRange","pointClass","pie","haloPath","addPoint","update","userOptions","oldtranslateX","oldtranslateY","scaleX","scaleY","attrSetters","getDataLabelPosition","connectorPosition","natural","breakAt","touchingSliceAt","pointAttribs","_i","slicedTranslation","slicedOffset","drawTracker","applyOptions","tooltip","pointFormat","axisTypes","directTouch","parallelArrays","pointArrayMap","registerSeriesType","area","Axis","Tick","Chart","Fx","Series"],"sources":["C:\\Users\\prati\\OneDrive\\Desktop\\my docs\\book\\frotend\\node_modules\\highcharts\\<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * 3D features for Highcharts JS\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/highcharts-3d', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Core/Math3D.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { deg2rad } = H;\n        const { pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /* eslint-disable max-len */\n        /**\n         * Apply 3-D rotation\n         * Euler Angles (XYZ):\n         *     cosA = cos(Alfa|Roll)\n         *     cosB = cos(Beta|Pitch)\n         *     cosG = cos(Gamma|Yaw)\n         *\n         * Composite rotation:\n         * |          cosB * cosG             |           cosB * sinG            |    -sinB    |\n         * | sinA * sinB * cosG - cosA * sinG | sinA * sinB * sinG + cosA * cosG | sinA * cosB |\n         * | cosA * sinB * cosG + sinA * sinG | cosA * sinB * sinG - sinA * cosG | cosA * cosB |\n         *\n         * Now, Gamma/Yaw is not used (angle=0), so we assume cosG = 1 and sinG = 0, so\n         * we get:\n         * |     cosB    |   0    |   - sinB    |\n         * | sinA * sinB |  cosA  | sinA * cosB |\n         * | cosA * sinB | - sinA | cosA * cosB |\n         *\n         * But in browsers, y is reversed, so we get sinA => -sinA. The general result\n         * is:\n         * |      cosB     |   0    |    - sinB     |     | x |     | px |\n         * | - sinA * sinB |  cosA  | - sinA * cosB |  x  | y |  =  | py |\n         * |  cosA * sinB  |  sinA  |  cosA * cosB  |     | z |     | pz |\n         *\n         * @private\n         * @function rotate3D\n         */\n        /* eslint-enable max-len */\n        /**\n         * Rotates the position as defined in angles.\n         * @private\n         * @param {number} x\n         *        X coordinate\n         * @param {number} y\n         *        Y coordinate\n         * @param {number} z\n         *        Z coordinate\n         * @param {Highcharts.Rotation3DObject} angles\n         *        Rotation angles\n         * @return {Highcharts.Position3DObject}\n         *         Rotated position\n         */\n        function rotate3D(x, y, z, angles) {\n            return {\n                x: angles.cosB * x - angles.sinB * z,\n                y: -angles.sinA * angles.sinB * x + angles.cosA * y -\n                    angles.cosB * angles.sinA * z,\n                z: angles.cosA * angles.sinB * x + angles.sinA * y +\n                    angles.cosA * angles.cosB * z\n            };\n        }\n        /**\n         * Transforms a given array of points according to the angles in chart.options.\n         *\n         * @private\n         * @function Highcharts.perspective\n         *\n         * @param {Array<Highcharts.Position3DObject>} points\n         * The array of points\n         *\n         * @param {Highcharts.Chart} chart\n         * The chart\n         *\n         * @param {boolean} [insidePlotArea]\n         * Whether to verify that the points are inside the plotArea\n         *\n         * @param {boolean} [useInvertedPersp]\n         * Whether to use inverted perspective in calculations\n         *\n         * @return {Array<Highcharts.Position3DObject>}\n         * An array of transformed points\n         *\n         * @requires highcharts-3d\n         */\n        function perspective(points, chart, insidePlotArea, useInvertedPersp) {\n            const options3d = chart.options.chart.options3d, \n            /* The useInvertedPersp argument is used for inverted charts with\n             * already inverted elements, such as dataLabels or tooltip positions.\n             */\n            inverted = pick(useInvertedPersp, insidePlotArea ? chart.inverted : false), origin = {\n                x: chart.plotWidth / 2,\n                y: chart.plotHeight / 2,\n                z: options3d.depth / 2,\n                vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n            }, scale = chart.scale3d || 1, beta = deg2rad * options3d.beta * (inverted ? -1 : 1), alpha = deg2rad * options3d.alpha * (inverted ? -1 : 1), angles = {\n                cosA: Math.cos(alpha),\n                cosB: Math.cos(-beta),\n                sinA: Math.sin(alpha),\n                sinB: Math.sin(-beta)\n            };\n            if (!insidePlotArea) {\n                origin.x += chart.plotLeft;\n                origin.y += chart.plotTop;\n            }\n            // Transform each point\n            return points.map(function (point) {\n                const rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles), \n                // Apply perspective\n                coordinate = perspective3D(rotated, origin, origin.vd);\n                // Apply translation\n                coordinate.x = coordinate.x * scale + origin.x;\n                coordinate.y = coordinate.y * scale + origin.y;\n                coordinate.z = rotated.z * scale + origin.z;\n                return {\n                    x: (inverted ? coordinate.y : coordinate.x),\n                    y: (inverted ? coordinate.x : coordinate.y),\n                    z: coordinate.z\n                };\n            });\n        }\n        /**\n         * Perspective3D function is available in global Highcharts scope because is\n         * needed also outside of perspective() function (#8042).\n         * @private\n         * @function Highcharts.perspective3D\n         *\n         * @param {Highcharts.Position3DObject} coordinate\n         * 3D position\n         *\n         * @param {Highcharts.Position3DObject} origin\n         * 3D root position\n         *\n         * @param {number} distance\n         * Perspective distance\n         *\n         * @return {Highcharts.PositionObject}\n         * Perspective 3D Position\n         *\n         * @requires highcharts-3d\n         */\n        function perspective3D(coordinate, origin, distance) {\n            const projection = ((distance > 0) &&\n                (distance < Number.POSITIVE_INFINITY)) ?\n                distance / (coordinate.z + origin.z + distance) :\n                1;\n            return {\n                x: coordinate.x * projection,\n                y: coordinate.y * projection\n            };\n        }\n        /**\n         * Calculate a distance from camera to points - made for calculating zIndex of\n         * scatter points.\n         *\n         * @private\n         * @function Highcharts.pointCameraDistance\n         *\n         * @param {Highcharts.Dictionary<number>} coordinates\n         * Coordinates of the specific point\n         *\n         * @param {Highcharts.Chart} chart\n         * Related chart\n         *\n         * @return {number}\n         * Distance from camera to point\n         *\n         * @requires highcharts-3d\n         */\n        function pointCameraDistance(coordinates, chart) {\n            const options3d = chart.options.chart.options3d, cameraPosition = {\n                x: chart.plotWidth / 2,\n                y: chart.plotHeight / 2,\n                z: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0) +\n                    options3d.depth\n            }, \n            // Added support for objects with plotX or x coordinates.\n            distance = Math.sqrt(Math.pow(cameraPosition.x - pick(coordinates.plotX, coordinates.x), 2) +\n                Math.pow(cameraPosition.y - pick(coordinates.plotY, coordinates.y), 2) +\n                Math.pow(cameraPosition.z - pick(coordinates.plotZ, coordinates.z), 2));\n            return distance;\n        }\n        /**\n         * Calculate area of a 2D polygon using Shoelace algorithm\n         * https://en.wikipedia.org/wiki/Shoelace_formula\n         *\n         * @private\n         * @function Highcharts.shapeArea\n         *\n         * @param {Array<Highcharts.PositionObject>} vertexes\n         * 2D Polygon\n         *\n         * @return {number}\n         * Calculated area\n         *\n         * @requires highcharts-3d\n         */\n        function shapeArea(vertexes) {\n            let area = 0, i, j;\n            for (i = 0; i < vertexes.length; i++) {\n                j = (i + 1) % vertexes.length;\n                area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;\n            }\n            return area / 2;\n        }\n        /**\n         * Calculate area of a 3D polygon after perspective projection\n         *\n         * @private\n         * @function Highcharts.shapeArea3d\n         *\n         * @param {Array<Highcharts.Position3DObject>} vertexes\n         * 3D Polygon\n         *\n         * @param {Highcharts.Chart} chart\n         * Related chart\n         *\n         * @param {boolean} [insidePlotArea]\n         * Whether to verify that the points are inside the plotArea\n         *\n         * @return {number}\n         * Calculated area\n         *\n         * @requires highcharts-3d\n         */\n        function shapeArea3D(vertexes, chart, insidePlotArea) {\n            return shapeArea(perspective(vertexes, chart, insidePlotArea));\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const Math3D = {\n            perspective,\n            perspective3D,\n            pointCameraDistance,\n            shapeArea,\n            shapeArea3D\n        };\n\n        return Math3D;\n    });\n    _registerModule(_modules, 'Core/Chart/Chart3D.js', [_modules['Core/Color/Color.js'], _modules['Core/Defaults.js'], _modules['Core/Math3D.js'], _modules['Core/Utilities.js']], function (Color, D, Math3D, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extension for 3D charts\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { parse: color } = Color;\n        const { defaultOptions: genericDefaultOptions } = D;\n        const { perspective, shapeArea3D } = Math3D;\n        const { addEvent, isArray, merge, pick, wrap } = U;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var Chart3D;\n        (function (Chart3D) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            /**\n             * @optionparent\n             * @private\n             */\n            Chart3D.defaultOptions = {\n                chart: {\n                    /**\n                     * Options to render charts in 3 dimensions. This feature requires\n                     * `highcharts-3d.js`, found in the download package or online at\n                     * [code.highcharts.com/highcharts-3d.js](https://code.highcharts.com/highcharts-3d.js).\n                     *\n                     * @since    4.0\n                     * @product  highcharts\n                     * @requires highcharts-3d\n                     */\n                    options3d: {\n                        /**\n                         * Whether to render the chart using the 3D functionality.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        enabled: false,\n                        /**\n                         * One of the two rotation angles for the chart.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        alpha: 0,\n                        /**\n                         * One of the two rotation angles for the chart.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        beta: 0,\n                        /**\n                         * The total depth of the chart.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        depth: 100,\n                        /**\n                         * Whether the 3d box should automatically adjust to the chart\n                         * plot area.\n                         *\n                         * @since   4.2.4\n                         * @product highcharts\n                         */\n                        fitToPlot: true,\n                        /**\n                         * Defines the distance the viewer is standing in front of the\n                         * chart, this setting is important to calculate the perspective\n                         * effect in column and scatter charts. It is not used for 3D\n                         * pie charts.\n                         *\n                         * @since   4.0\n                         * @product highcharts\n                         */\n                        viewDistance: 25,\n                        /**\n                         * Set it to `\"auto\"` to automatically move the labels to the\n                         * best edge.\n                         *\n                         * @type    {\"auto\"|null}\n                         * @since   5.0.12\n                         * @product highcharts\n                         */\n                        axisLabelPosition: null,\n                        /**\n                         * Provides the option to draw a frame around the charts by\n                         * defining a bottom, front and back panel.\n                         *\n                         * @since    4.0\n                         * @product  highcharts\n                         * @requires highcharts-3d\n                         */\n                        frame: {\n                            /**\n                             * Whether the frames are visible.\n                             */\n                            visible: 'default',\n                            /**\n                             * General pixel thickness for the frame faces.\n                             */\n                            size: 1,\n                            /**\n                             * The bottom of the frame around a 3D chart.\n                             *\n                             * @since    4.0\n                             * @product  highcharts\n                             * @requires highcharts-3d\n                             */\n                            /**\n                             * The color of the panel.\n                             *\n                             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                             * @default   transparent\n                             * @since     4.0\n                             * @product   highcharts\n                             * @apioption chart.options3d.frame.bottom.color\n                             */\n                            /**\n                             * The thickness of the panel.\n                             *\n                             * @type      {number}\n                             * @default   1\n                             * @since     4.0\n                             * @product   highcharts\n                             * @apioption chart.options3d.frame.bottom.size\n                             */\n                            /**\n                             * Whether to display the frame. Possible values are `true`,\n                             * `false`, `\"auto\"` to display only the frames behind the\n                             * data, and `\"default\"` to display faces behind the data\n                             * based on the axis layout, ignoring the point of view.\n                             *\n                             * @sample {highcharts} highcharts/3d/scatter-frame/\n                             *         Auto frames\n                             *\n                             * @type      {boolean|\"default\"|\"auto\"}\n                             * @default   default\n                             * @since     5.0.12\n                             * @product   highcharts\n                             * @apioption chart.options3d.frame.bottom.visible\n                             */\n                            /**\n                             * The bottom of the frame around a 3D chart.\n                             */\n                            bottom: {},\n                            /**\n                             * The top of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            top: {},\n                            /**\n                             * The left side of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            left: {},\n                            /**\n                             * The right of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            right: {},\n                            /**\n                             * The back side of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            back: {},\n                            /**\n                             * The front of the frame around a 3D chart.\n                             *\n                             * @extends chart.options3d.frame.bottom\n                             */\n                            front: {}\n                        }\n                    }\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            function compose(ChartClass, FxClass) {\n                const chartProto = ChartClass.prototype;\n                const fxProto = FxClass.prototype;\n                /**\n                 * Shorthand to check the is3d flag.\n                 * @private\n                 * @return {boolean}\n                 * Whether it is a 3D chart.\n                 */\n                chartProto.is3d = function () {\n                    return Boolean(this.options.chart.options3d &&\n                        this.options.chart.options3d.enabled); // #4280\n                };\n                chartProto.propsRequireDirtyBox.push('chart.options3d');\n                chartProto.propsRequireUpdateSeries.push('chart.options3d');\n                /**\n                 * Animation setter for matrix property.\n                 * @private\n                 */\n                fxProto.matrixSetter = function () {\n                    let interpolated;\n                    if (this.pos < 1 &&\n                        (isArray(this.start) || isArray(this.end))) {\n                        const start = (this.start ||\n                            [1, 0, 0, 1, 0, 0]), end = this.end || [1, 0, 0, 1, 0, 0];\n                        interpolated = [];\n                        for (let i = 0; i < 6; i++) {\n                            interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);\n                        }\n                    }\n                    else {\n                        interpolated = this.end;\n                    }\n                    this.elem.attr(this.prop, interpolated, null, true);\n                };\n                merge(true, genericDefaultOptions, Chart3D.defaultOptions);\n                addEvent(ChartClass, 'init', onInit);\n                addEvent(ChartClass, 'addSeries', onAddSeries);\n                addEvent(ChartClass, 'afterDrawChartBox', onAfterDrawChartBox);\n                addEvent(ChartClass, 'afterGetContainer', onAfterGetContainer);\n                addEvent(ChartClass, 'afterInit', onAfterInit);\n                addEvent(ChartClass, 'afterSetChartSize', onAfterSetChartSize);\n                addEvent(ChartClass, 'beforeRedraw', onBeforeRedraw);\n                addEvent(ChartClass, 'beforeRender', onBeforeRender);\n                wrap(chartProto, 'isInsidePlot', wrapIsInsidePlot);\n                wrap(chartProto, 'renderSeries', wrapRenderSeries);\n                wrap(chartProto, 'setClassName', wrapSetClassName);\n            }\n            Chart3D.compose = compose;\n            /**\n             * Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to\n             * the real 'scatter3d' series type. (#8407)\n             * @private\n             */\n            function onAddSeries(e) {\n                if (this.is3d()) {\n                    if (e.options.type === 'scatter') {\n                        e.options.type = 'scatter3d';\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onAfterDrawChartBox() {\n                if (this.chart3d &&\n                    this.is3d()) {\n                    const chart = this, renderer = chart.renderer, options3d = chart.options.chart.options3d, frame = chart.chart3d.get3dFrame(), xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, xmm = xm - (frame.left.visible ? frame.left.size : 0), xpp = xp + (frame.right.visible ? frame.right.size : 0), ymm = ym - (frame.top.visible ? frame.top.size : 0), ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0), zmm = zm - (frame.front.visible ? frame.front.size : 0), zpp = zp + (frame.back.visible ? frame.back.size : 0), verb = chart.hasRendered ? 'animate' : 'attr';\n                    chart.chart3d.frame3d = frame;\n                    if (!chart.frameShapes) {\n                        chart.frameShapes = {\n                            bottom: renderer.polyhedron().add(),\n                            top: renderer.polyhedron().add(),\n                            left: renderer.polyhedron().add(),\n                            right: renderer.polyhedron().add(),\n                            back: renderer.polyhedron().add(),\n                            front: renderer.polyhedron().add()\n                        };\n                    }\n                    chart.frameShapes.bottom[verb]({\n                        'class': 'highcharts-3d-frame highcharts-3d-frame-bottom',\n                        zIndex: frame.bottom.frontFacing ? -1000 : 1000,\n                        faces: [{\n                                fill: color(frame.bottom.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }],\n                                enabled: frame.bottom.visible\n                            },\n                            {\n                                fill: color(frame.bottom.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.bottom.visible\n                            },\n                            {\n                                fill: color(frame.bottom.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.bottom.visible && !frame.left.visible\n                            },\n                            {\n                                fill: color(frame.bottom.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }],\n                                enabled: frame.bottom.visible && !frame.right.visible\n                            },\n                            {\n                                fill: color(frame.bottom.color).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.bottom.visible && !frame.front.visible\n                            },\n                            {\n                                fill: color(frame.bottom.color).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }],\n                                enabled: frame.bottom.visible && !frame.back.visible\n                            }]\n                    });\n                    chart.frameShapes.top[verb]({\n                        'class': 'highcharts-3d-frame highcharts-3d-frame-top',\n                        zIndex: frame.top.frontFacing ? -1000 : 1000,\n                        faces: [{\n                                fill: color(frame.top.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }],\n                                enabled: frame.top.visible\n                            },\n                            {\n                                fill: color(frame.top.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.top.visible\n                            },\n                            {\n                                fill: color(frame.top.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.top.visible && !frame.left.visible\n                            },\n                            {\n                                fill: color(frame.top.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }],\n                                enabled: frame.top.visible && !frame.right.visible\n                            },\n                            {\n                                fill: color(frame.top.color).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }],\n                                enabled: frame.top.visible && !frame.front.visible\n                            },\n                            {\n                                fill: color(frame.top.color).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.top.visible && !frame.back.visible\n                            }]\n                    });\n                    chart.frameShapes.left[verb]({\n                        'class': 'highcharts-3d-frame highcharts-3d-frame-left',\n                        zIndex: frame.left.frontFacing ? -1000 : 1000,\n                        faces: [{\n                                fill: color(frame.left.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }],\n                                enabled: frame.left.visible && !frame.bottom.visible\n                            },\n                            {\n                                fill: color(frame.left.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }],\n                                enabled: frame.left.visible && !frame.top.visible\n                            },\n                            {\n                                fill: color(frame.left.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }],\n                                enabled: frame.left.visible\n                            },\n                            {\n                                fill: color(frame.left.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }],\n                                enabled: frame.left.visible\n                            },\n                            {\n                                fill: color(frame.left.color).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.left.visible && !frame.front.visible\n                            },\n                            {\n                                fill: color(frame.left.color).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.left.visible && !frame.back.visible\n                            }]\n                    });\n                    chart.frameShapes.right[verb]({\n                        'class': 'highcharts-3d-frame highcharts-3d-frame-right',\n                        zIndex: frame.right.frontFacing ? -1000 : 1000,\n                        faces: [{\n                                fill: color(frame.right.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }],\n                                enabled: frame.right.visible && !frame.bottom.visible\n                            },\n                            {\n                                fill: color(frame.right.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }],\n                                enabled: frame.right.visible && !frame.top.visible\n                            },\n                            {\n                                fill: color(frame.right.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.right.visible\n                            },\n                            {\n                                fill: color(frame.right.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }],\n                                enabled: frame.right.visible\n                            },\n                            {\n                                fill: color(frame.right.color).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }],\n                                enabled: frame.right.visible && !frame.front.visible\n                            },\n                            {\n                                fill: color(frame.right.color).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }],\n                                enabled: frame.right.visible && !frame.back.visible\n                            }]\n                    });\n                    chart.frameShapes.back[verb]({\n                        'class': 'highcharts-3d-frame highcharts-3d-frame-back',\n                        zIndex: frame.back.frontFacing ? -1000 : 1000,\n                        faces: [{\n                                fill: color(frame.back.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }],\n                                enabled: frame.back.visible && !frame.bottom.visible\n                            },\n                            {\n                                fill: color(frame.back.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.back.visible && !frame.top.visible\n                            },\n                            {\n                                fill: color(frame.back.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }],\n                                enabled: frame.back.visible && !frame.left.visible\n                            },\n                            {\n                                fill: color(frame.back.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }],\n                                enabled: frame.back.visible && !frame.right.visible\n                            },\n                            {\n                                fill: color(frame.back.color).get(),\n                                vertexes: [{\n                                        x: xm,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zp\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zp\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zp\n                                    }],\n                                enabled: frame.back.visible\n                            },\n                            {\n                                fill: color(frame.back.color).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zpp\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zpp\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zpp\n                                    }],\n                                enabled: frame.back.visible\n                            }]\n                    });\n                    chart.frameShapes.front[verb]({\n                        'class': 'highcharts-3d-frame highcharts-3d-frame-front',\n                        zIndex: frame.front.frontFacing ? -1000 : 1000,\n                        faces: [{\n                                fill: color(frame.front.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.front.visible && !frame.bottom.visible\n                            },\n                            {\n                                fill: color(frame.front.color).brighten(0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }],\n                                enabled: frame.front.visible && !frame.top.visible\n                            },\n                            {\n                                fill: color(frame.front.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }],\n                                enabled: frame.front.visible && !frame.left.visible\n                            },\n                            {\n                                fill: color(frame.front.color).brighten(-0.1).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.front.visible && !frame.right.visible\n                            },\n                            {\n                                fill: color(frame.front.color).get(),\n                                vertexes: [{\n                                        x: xp,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: ym,\n                                        z: zm\n                                    }, {\n                                        x: xm,\n                                        y: yp,\n                                        z: zm\n                                    }, {\n                                        x: xp,\n                                        y: yp,\n                                        z: zm\n                                    }],\n                                enabled: frame.front.visible\n                            },\n                            {\n                                fill: color(frame.front.color).get(),\n                                vertexes: [{\n                                        x: xpp,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ypp,\n                                        z: zmm\n                                    }, {\n                                        x: xmm,\n                                        y: ymm,\n                                        z: zmm\n                                    }, {\n                                        x: xpp,\n                                        y: ymm,\n                                        z: zmm\n                                    }],\n                                enabled: frame.front.visible\n                            }]\n                    });\n                }\n            }\n            /**\n             * Add the required CSS classes for column sides (#6018)\n             * @private\n             */\n            function onAfterGetContainer() {\n                if (this.styledMode) {\n                    // Add definitions used by brighter and darker faces of the cuboids.\n                    [{\n                            name: 'darker',\n                            slope: 0.6\n                        }, {\n                            name: 'brighter',\n                            slope: 1.4\n                        }].forEach(function (cfg) {\n                        this.renderer.definition({\n                            tagName: 'filter',\n                            attributes: {\n                                id: 'highcharts-' + cfg.name\n                            },\n                            children: [{\n                                    tagName: 'feComponentTransfer',\n                                    children: [{\n                                            tagName: 'feFuncR',\n                                            attributes: {\n                                                type: 'linear',\n                                                slope: cfg.slope\n                                            }\n                                        }, {\n                                            tagName: 'feFuncG',\n                                            attributes: {\n                                                type: 'linear',\n                                                slope: cfg.slope\n                                            }\n                                        }, {\n                                            tagName: 'feFuncB',\n                                            attributes: {\n                                                type: 'linear',\n                                                slope: cfg.slope\n                                            }\n                                        }]\n                                }]\n                        });\n                    }, this);\n                }\n            }\n            /**\n             * Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to\n             * the real 'scatter3d' series type. (#8407)\n             * @private\n             */\n            function onAfterInit() {\n                const options = this.options;\n                if (this.is3d()) {\n                    (options.series || []).forEach(function (s) {\n                        const type = (s.type ||\n                            options.chart.type ||\n                            options.chart.defaultSeriesType);\n                        if (type === 'scatter') {\n                            s.type = 'scatter3d';\n                        }\n                    });\n                }\n            }\n            /**\n             * @private\n             */\n            function onAfterSetChartSize() {\n                const chart = this, options3d = chart.options.chart.options3d;\n                if (chart.chart3d &&\n                    chart.is3d()) {\n                    // Add a 0-360 normalisation for alfa and beta angles in 3d graph\n                    if (options3d) {\n                        options3d.alpha = options3d.alpha % 360 +\n                            (options3d.alpha >= 0 ? 0 : 360);\n                        options3d.beta = options3d.beta % 360 +\n                            (options3d.beta >= 0 ? 0 : 360);\n                    }\n                    const inverted = chart.inverted, clipBox = chart.clipBox, margin = chart.margin, x = inverted ? 'y' : 'x', y = inverted ? 'x' : 'y', w = inverted ? 'height' : 'width', h = inverted ? 'width' : 'height';\n                    clipBox[x] = -(margin[3] || 0);\n                    clipBox[y] = -(margin[0] || 0);\n                    clipBox[w] = (chart.chartWidth + (margin[3] || 0) + (margin[1] || 0));\n                    clipBox[h] = (chart.chartHeight + (margin[0] || 0) + (margin[2] || 0));\n                    // Set scale, used later in perspective method():\n                    // getScale uses perspective, so scale3d has to be reset.\n                    chart.scale3d = 1;\n                    if (options3d.fitToPlot === true) {\n                        chart.scale3d = chart.chart3d.getScale(options3d.depth);\n                    }\n                    // Recalculate the 3d frame with every call of setChartSize,\n                    // instead of doing it after every redraw(). It avoids ticks\n                    // and axis title outside of chart.\n                    chart.chart3d.frame3d = chart.chart3d.get3dFrame(); // #7942\n                }\n            }\n            /**\n             * @private\n             */\n            function onBeforeRedraw() {\n                if (this.is3d()) {\n                    // Set to force a redraw of all elements\n                    this.isDirtyBox = true;\n                }\n            }\n            /**\n             * @private\n             */\n            function onBeforeRender() {\n                if (this.chart3d && this.is3d()) {\n                    this.chart3d.frame3d = this.chart3d.get3dFrame();\n                }\n            }\n            /**\n             * @private\n             */\n            function onInit() {\n                if (!this.chart3d) {\n                    this.chart3d = new Additions(this);\n                }\n            }\n            /**\n             * @private\n             */\n            function wrapIsInsidePlot(proceed) {\n                return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            /**\n             * Draw the series in the reverse order (#3803, #3917)\n             * @private\n             */\n            function wrapRenderSeries(proceed) {\n                let series, i = this.series.length;\n                if (this.is3d()) {\n                    while (i--) {\n                        series = this.series[i];\n                        series.translate();\n                        series.render();\n                    }\n                }\n                else {\n                    proceed.call(this);\n                }\n            }\n            /**\n             * @private\n             */\n            function wrapSetClassName(proceed) {\n                proceed.apply(this, [].slice.call(arguments, 1));\n                if (this.is3d()) {\n                    this.container.className += ' highcharts-3d-chart';\n                }\n            }\n            /* *\n             *\n             *  Class\n             *\n             * */\n            class Additions {\n                /* *\n                 *\n                 *  Constructors\n                 *\n                 * */\n                constructor(chart) {\n                    this.frame3d = void 0;\n                    this.chart = chart;\n                }\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                get3dFrame() {\n                    const chart = this.chart, options3d = chart.options.chart.options3d, frameOptions = options3d.frame, xm = chart.plotLeft, xp = chart.plotLeft + chart.plotWidth, ym = chart.plotTop, yp = chart.plotTop + chart.plotHeight, zm = 0, zp = options3d.depth, faceOrientation = function (vertexes) {\n                        const area = shapeArea3D(vertexes, chart);\n                        // Give it 0.5 squared-pixel as a margin for rounding errors\n                        if (area > 0.5) {\n                            return 1;\n                        }\n                        if (area < -0.5) {\n                            return -1;\n                        }\n                        return 0;\n                    }, bottomOrientation = faceOrientation([\n                        { x: xm, y: yp, z: zp },\n                        { x: xp, y: yp, z: zp },\n                        { x: xp, y: yp, z: zm },\n                        { x: xm, y: yp, z: zm }\n                    ]), topOrientation = faceOrientation([\n                        { x: xm, y: ym, z: zm },\n                        { x: xp, y: ym, z: zm },\n                        { x: xp, y: ym, z: zp },\n                        { x: xm, y: ym, z: zp }\n                    ]), leftOrientation = faceOrientation([\n                        { x: xm, y: ym, z: zm },\n                        { x: xm, y: ym, z: zp },\n                        { x: xm, y: yp, z: zp },\n                        { x: xm, y: yp, z: zm }\n                    ]), rightOrientation = faceOrientation([\n                        { x: xp, y: ym, z: zp },\n                        { x: xp, y: ym, z: zm },\n                        { x: xp, y: yp, z: zm },\n                        { x: xp, y: yp, z: zp }\n                    ]), frontOrientation = faceOrientation([\n                        { x: xm, y: yp, z: zm },\n                        { x: xp, y: yp, z: zm },\n                        { x: xp, y: ym, z: zm },\n                        { x: xm, y: ym, z: zm }\n                    ]), backOrientation = faceOrientation([\n                        { x: xm, y: ym, z: zp },\n                        { x: xp, y: ym, z: zp },\n                        { x: xp, y: yp, z: zp },\n                        { x: xm, y: yp, z: zp }\n                    ]), defaultShowFront = false, defaultShowBack = true;\n                    let defaultShowBottom = false, defaultShowTop = false, defaultShowLeft = false, defaultShowRight = false;\n                    // The 'default' criteria to visible faces of the frame is looking\n                    // up every axis to decide whenever the left/right//top/bottom sides\n                    // of the frame will be shown\n                    []\n                        .concat(chart.xAxis, chart.yAxis, chart.zAxis)\n                        .forEach(function (axis) {\n                        if (axis) {\n                            if (axis.horiz) {\n                                if (axis.opposite) {\n                                    defaultShowTop = true;\n                                }\n                                else {\n                                    defaultShowBottom = true;\n                                }\n                            }\n                            else {\n                                if (axis.opposite) {\n                                    defaultShowRight = true;\n                                }\n                                else {\n                                    defaultShowLeft = true;\n                                }\n                            }\n                        }\n                    });\n                    const getFaceOptions = function (sources, faceOrientation, defaultVisible) {\n                        const faceAttrs = ['size', 'color', 'visible'], options = {};\n                        for (let i = 0; i < faceAttrs.length; i++) {\n                            const attr = faceAttrs[i];\n                            for (let j = 0; j < sources.length; j++) {\n                                if (typeof sources[j] === 'object') {\n                                    const val = sources[j][attr];\n                                    if (typeof val !== 'undefined' && val !== null) {\n                                        options[attr] = val;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        let isVisible = defaultVisible;\n                        if (options.visible === true || options.visible === false) {\n                            isVisible = options.visible;\n                        }\n                        else if (options.visible === 'auto') {\n                            isVisible = faceOrientation > 0;\n                        }\n                        return {\n                            size: pick(options.size, 1),\n                            color: pick(options.color, 'none'),\n                            frontFacing: faceOrientation > 0,\n                            visible: isVisible\n                        };\n                    };\n                    // docs @TODO: Add all frame options (left, right, top, bottom,\n                    // front, back) to apioptions JSDoc once the new system is up.\n                    const ret = {\n                        axes: {},\n                        // FIXME: Previously, left/right, top/bottom and front/back\n                        // pairs shared size and color.\n                        // For compatibility and consistency sake, when one face have\n                        // size/color/visibility set, the opposite face will default to\n                        // the same values. Also, left/right used to be called 'side',\n                        // so that's also added as a fallback.\n                        bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),\n                        top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),\n                        left: getFaceOptions([\n                            frameOptions.left,\n                            frameOptions.right,\n                            frameOptions.side,\n                            frameOptions\n                        ], leftOrientation, defaultShowLeft),\n                        right: getFaceOptions([\n                            frameOptions.right,\n                            frameOptions.left,\n                            frameOptions.side,\n                            frameOptions\n                        ], rightOrientation, defaultShowRight),\n                        back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),\n                        front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)\n                    };\n                    // Decide the bast place to put axis title/labels based on the\n                    // visible faces. Ideally, The labels can only be on the edge\n                    // between a visible face and an invisble one. Also, the Y label\n                    // should be one the left-most edge (right-most if opposite).\n                    if (options3d.axisLabelPosition === 'auto') {\n                        const isValidEdge = function (face1, face2) {\n                            return ((face1.visible !== face2.visible) ||\n                                (face1.visible &&\n                                    face2.visible &&\n                                    (face1.frontFacing !== face2.frontFacing)));\n                        };\n                        const yEdges = [];\n                        if (isValidEdge(ret.left, ret.front)) {\n                            yEdges.push({\n                                y: (ym + yp) / 2,\n                                x: xm,\n                                z: zm,\n                                xDir: { x: 1, y: 0, z: 0 }\n                            });\n                        }\n                        if (isValidEdge(ret.left, ret.back)) {\n                            yEdges.push({\n                                y: (ym + yp) / 2,\n                                x: xm,\n                                z: zp,\n                                xDir: { x: 0, y: 0, z: -1 }\n                            });\n                        }\n                        if (isValidEdge(ret.right, ret.front)) {\n                            yEdges.push({\n                                y: (ym + yp) / 2,\n                                x: xp,\n                                z: zm,\n                                xDir: { x: 0, y: 0, z: 1 }\n                            });\n                        }\n                        if (isValidEdge(ret.right, ret.back)) {\n                            yEdges.push({\n                                y: (ym + yp) / 2,\n                                x: xp,\n                                z: zp,\n                                xDir: { x: -1, y: 0, z: 0 }\n                            });\n                        }\n                        const xBottomEdges = [];\n                        if (isValidEdge(ret.bottom, ret.front)) {\n                            xBottomEdges.push({\n                                x: (xm + xp) / 2,\n                                y: yp,\n                                z: zm,\n                                xDir: { x: 1, y: 0, z: 0 }\n                            });\n                        }\n                        if (isValidEdge(ret.bottom, ret.back)) {\n                            xBottomEdges.push({\n                                x: (xm + xp) / 2,\n                                y: yp,\n                                z: zp,\n                                xDir: { x: -1, y: 0, z: 0 }\n                            });\n                        }\n                        const xTopEdges = [];\n                        if (isValidEdge(ret.top, ret.front)) {\n                            xTopEdges.push({\n                                x: (xm + xp) / 2,\n                                y: ym,\n                                z: zm,\n                                xDir: { x: 1, y: 0, z: 0 }\n                            });\n                        }\n                        if (isValidEdge(ret.top, ret.back)) {\n                            xTopEdges.push({\n                                x: (xm + xp) / 2,\n                                y: ym,\n                                z: zp,\n                                xDir: { x: -1, y: 0, z: 0 }\n                            });\n                        }\n                        const zBottomEdges = [];\n                        if (isValidEdge(ret.bottom, ret.left)) {\n                            zBottomEdges.push({\n                                z: (zm + zp) / 2,\n                                y: yp,\n                                x: xm,\n                                xDir: { x: 0, y: 0, z: -1 }\n                            });\n                        }\n                        if (isValidEdge(ret.bottom, ret.right)) {\n                            zBottomEdges.push({\n                                z: (zm + zp) / 2,\n                                y: yp,\n                                x: xp,\n                                xDir: { x: 0, y: 0, z: 1 }\n                            });\n                        }\n                        const zTopEdges = [];\n                        if (isValidEdge(ret.top, ret.left)) {\n                            zTopEdges.push({\n                                z: (zm + zp) / 2,\n                                y: ym,\n                                x: xm,\n                                xDir: { x: 0, y: 0, z: -1 }\n                            });\n                        }\n                        if (isValidEdge(ret.top, ret.right)) {\n                            zTopEdges.push({\n                                z: (zm + zp) / 2,\n                                y: ym,\n                                x: xp,\n                                xDir: { x: 0, y: 0, z: 1 }\n                            });\n                        }\n                        const pickEdge = function (edges, axis, mult) {\n                            if (edges.length === 0) {\n                                return null;\n                            }\n                            if (edges.length === 1) {\n                                return edges[0];\n                            }\n                            const projections = perspective(edges, chart, false);\n                            let best = 0;\n                            for (let i = 1; i < projections.length; i++) {\n                                if (mult * projections[i][axis] >\n                                    mult * projections[best][axis]) {\n                                    best = i;\n                                }\n                                else if ((mult * projections[i][axis] ===\n                                    mult * projections[best][axis]) &&\n                                    (projections[i].z < projections[best].z)) {\n                                    best = i;\n                                }\n                            }\n                            return edges[best];\n                        };\n                        ret.axes = {\n                            y: {\n                                'left': pickEdge(yEdges, 'x', -1),\n                                'right': pickEdge(yEdges, 'x', +1)\n                            },\n                            x: {\n                                'top': pickEdge(xTopEdges, 'y', -1),\n                                'bottom': pickEdge(xBottomEdges, 'y', +1)\n                            },\n                            z: {\n                                'top': pickEdge(zTopEdges, 'y', -1),\n                                'bottom': pickEdge(zBottomEdges, 'y', +1)\n                            }\n                        };\n                    }\n                    else {\n                        ret.axes = {\n                            y: {\n                                'left': {\n                                    x: xm, z: zm, xDir: { x: 1, y: 0, z: 0 }\n                                },\n                                'right': {\n                                    x: xp, z: zm, xDir: { x: 0, y: 0, z: 1 }\n                                }\n                            },\n                            x: {\n                                'top': {\n                                    y: ym, z: zm, xDir: { x: 1, y: 0, z: 0 }\n                                },\n                                'bottom': {\n                                    y: yp,\n                                    z: zm,\n                                    xDir: { x: 1, y: 0, z: 0 }\n                                }\n                            },\n                            z: {\n                                'top': {\n                                    x: defaultShowLeft ? xp : xm,\n                                    y: ym,\n                                    xDir: defaultShowLeft ?\n                                        { x: 0, y: 0, z: 1 } :\n                                        { x: 0, y: 0, z: -1 }\n                                },\n                                'bottom': {\n                                    x: defaultShowLeft ? xp : xm,\n                                    y: yp,\n                                    xDir: defaultShowLeft ?\n                                        { x: 0, y: 0, z: 1 } :\n                                        { x: 0, y: 0, z: -1 }\n                                }\n                            }\n                        };\n                    }\n                    return ret;\n                }\n                /**\n                 * Calculate scale of the 3D view. That is required to fit chart's 3D\n                 * projection into the actual plotting area. Reported as #4933.\n                 *\n                 * **Note:**\n                 * This function should ideally take the plot values instead of a chart\n                 * object, but since the chart object is needed for perspective it is\n                 * not practical. Possible to make both getScale and perspective more\n                 * logical and also immutable.\n                 *\n                 * @private\n                 * @function getScale\n                 *\n                 * @param {number} depth\n                 * The depth of the chart\n                 *\n                 * @return {number}\n                 * The scale to fit the 3D chart into the plotting area.\n                 *\n                 * @requires highcharts-3d\n                 */\n                getScale(depth) {\n                    const chart = this.chart, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop, originX = plotLeft + chart.plotWidth / 2, originY = plotTop + chart.plotHeight / 2, bbox3d = {\n                        minX: Number.MAX_VALUE,\n                        maxX: -Number.MAX_VALUE,\n                        minY: Number.MAX_VALUE,\n                        maxY: -Number.MAX_VALUE\n                    };\n                    let corners, scale = 1;\n                    // Top left corners:\n                    corners = [{\n                            x: plotLeft,\n                            y: plotTop,\n                            z: 0\n                        }, {\n                            x: plotLeft,\n                            y: plotTop,\n                            z: depth\n                        }];\n                    // Top right corners:\n                    [0, 1].forEach(function (i) {\n                        corners.push({\n                            x: plotRight,\n                            y: corners[i].y,\n                            z: corners[i].z\n                        });\n                    });\n                    // All bottom corners:\n                    [0, 1, 2, 3].forEach(function (i) {\n                        corners.push({\n                            x: corners[i].x,\n                            y: plotBottom,\n                            z: corners[i].z\n                        });\n                    });\n                    // Calculate 3D corners:\n                    corners = perspective(corners, chart, false);\n                    // Get bounding box of 3D element:\n                    corners.forEach(function (corner) {\n                        bbox3d.minX = Math.min(bbox3d.minX, corner.x);\n                        bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);\n                        bbox3d.minY = Math.min(bbox3d.minY, corner.y);\n                        bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);\n                    });\n                    // Left edge:\n                    if (plotLeft > bbox3d.minX) {\n                        scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);\n                    }\n                    // Right edge:\n                    if (plotRight < bbox3d.maxX) {\n                        scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));\n                    }\n                    // Top edge:\n                    if (plotTop > bbox3d.minY) {\n                        if (bbox3d.minY < 0) {\n                            scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));\n                        }\n                        else {\n                            scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);\n                        }\n                    }\n                    // Bottom edge:\n                    if (plotBottom < bbox3d.maxY) {\n                        scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));\n                    }\n                    return scale;\n                }\n            }\n            Chart3D.Additions = Additions;\n        })(Chart3D || (Chart3D = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Note: As of v5.0.12, `frame.left` or `frame.right` should be used instead.\n         *\n         * The side for the frame around a 3D chart.\n         *\n         * @deprecated\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption chart.options3d.frame.side\n         */\n        /**\n         * The color of the panel.\n         *\n         * @deprecated\n         * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n         * @default   transparent\n         * @since     4.0\n         * @product   highcharts\n         * @apioption chart.options3d.frame.side.color\n         */\n        /**\n         * The thickness of the panel.\n         *\n         * @deprecated\n         * @type      {number}\n         * @default   1\n         * @since     4.0\n         * @product   highcharts\n         * @apioption chart.options3d.frame.side.size\n         */\n        ''; // keeps doclets above in JS file\n\n        return Chart3D;\n    });\n    _registerModule(_modules, 'Series/Area3D/Area3DSeries.js', [_modules['Core/Math3D.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Math3D, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachliński\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { perspective } = Math3D;\n        const { seriesTypes: { line: { prototype: lineProto } } } = SeriesRegistry;\n        const { wrap } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        function compose(AreaSeriesClass) {\n            if (U.pushUnique(composedMembers, AreaSeriesClass)) {\n                wrap(AreaSeriesClass.prototype, 'getGraphPath', wrapAreaSeriesGetGraphPath);\n            }\n        }\n        function wrapAreaSeriesGetGraphPath(proceed) {\n            const series = this, svgPath = proceed.apply(series, [].slice.call(arguments, 1));\n            // Do not do this if the chart is not 3D\n            if (!series.chart.is3d()) {\n                return svgPath;\n            }\n            const getGraphPath = lineProto.getGraphPath, options = series.options, translatedThreshold = Math.round(// #10909\n            series.yAxis.getThreshold(options.threshold));\n            let bottomPoints = [];\n            if (series.rawPointsX) {\n                for (let i = 0; i < series.points.length; i++) {\n                    bottomPoints.push({\n                        x: series.rawPointsX[i],\n                        y: options.stacking ?\n                            series.points[i].yBottom : translatedThreshold,\n                        z: series.zPadding\n                    });\n                }\n            }\n            const options3d = series.chart.options.chart.options3d;\n            bottomPoints = perspective(bottomPoints, series.chart, true).map((point) => ({ plotX: point.x, plotY: point.y, plotZ: point.z }));\n            if (series.group && options3d && options3d.depth && options3d.beta) {\n                // Markers should take the global zIndex of series group.\n                if (series.markerGroup) {\n                    series.markerGroup.add(series.group);\n                    series.markerGroup.attr({\n                        translateX: 0,\n                        translateY: 0\n                    });\n                }\n                series.group.attr({\n                    zIndex: Math.max(1, (options3d.beta > 270 || options3d.beta < 90) ?\n                        options3d.depth - Math.round(series.zPadding || 0) :\n                        Math.round(series.zPadding || 0))\n                });\n            }\n            bottomPoints.reversed = true;\n            const bottomPath = getGraphPath.call(series, bottomPoints, true, true);\n            if (bottomPath[0] && bottomPath[0][0] === 'M') {\n                bottomPath[0] = ['L', bottomPath[0][1], bottomPath[0][2]];\n            }\n            if (series.areaPath) {\n                // Remove previously used bottomPath and add the new one.\n                const areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath);\n                // Use old xMap in the new areaPath\n                areaPath.xMap = series.areaPath.xMap;\n                series.areaPath = areaPath;\n            }\n            return svgPath;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const Area3DSeries = {\n            compose\n        };\n\n        return Area3DSeries;\n    });\n    _registerModule(_modules, 'Core/Axis/Axis3DDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extenstion for 3d axes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * @optionparent xAxis\n         */\n        const Axis3DDefaults = {\n            labels: {\n                /**\n                 * Defines how the labels are be repositioned according to the 3D\n                 * chart orientation.\n                 *\n                 * - `'offset'`: Maintain a fixed horizontal/vertical distance from\n                 *   the tick marks, despite the chart orientation. This is the\n                 *   backwards compatible behavior, and causes skewing of X and Z\n                 *   axes.\n                 *\n                 * - `'chart'`: Preserve 3D position relative to the chart. This\n                 *   looks nice, but hard to read if the text isn't forward-facing.\n                 *\n                 * - `'flap'`: Rotated text along the axis to compensate for the\n                 *   chart orientation. This tries to maintain text as legible as\n                 *   possible on all orientations.\n                 *\n                 * - `'ortho'`: Rotated text along the axis direction so that the\n                 *   labels are orthogonal to the axis. This is very similar to\n                 *   `'flap'`, but prevents skewing the labels (X and Y scaling are\n                 *   still present).\n                 *\n                 * @sample highcharts/3d/skewed-labels/\n                 *         Skewed labels\n                 *\n                 * @since      5.0.15\n                 * @validvalue ['offset', 'chart', 'flap', 'ortho']\n                 * @product    highcharts\n                 * @requires   highcharts-3d\n                 */\n                position3d: 'offset',\n                /**\n                 * If enabled, the axis labels will skewed to follow the\n                 * perspective.\n                 *\n                 * This will fix overlapping labels and titles, but texts become\n                 * less legible due to the distortion.\n                 *\n                 * The final appearance depends heavily on `labels.position3d`.\n                 *\n                 * @sample highcharts/3d/skewed-labels/\n                 *         Skewed labels\n                 *\n                 * @since    5.0.15\n                 * @product  highcharts\n                 * @requires highcharts-3d\n                 */\n                skew3d: false\n            },\n            title: {\n                /**\n                 * Defines how the title is repositioned according to the 3D chart\n                 * orientation.\n                 *\n                 * - `'offset'`: Maintain a fixed horizontal/vertical distance from\n                 *   the tick marks, despite the chart orientation. This is the\n                 *   backwards compatible behavior, and causes skewing of X and Z\n                 *   axes.\n                 *\n                 * - `'chart'`: Preserve 3D position relative to the chart. This\n                 *   looks nice, but hard to read if the text isn't forward-facing.\n                 *\n                 * - `'flap'`: Rotated text along the axis to compensate for the\n                 *   chart orientation. This tries to maintain text as legible as\n                 *   possible on all orientations.\n                 *\n                 * - `'ortho'`: Rotated text along the axis direction so that the\n                 *   labels are orthogonal to the axis. This is very similar to\n                 *   `'flap'`, but prevents skewing the labels (X and Y scaling are\n                 *   still present).\n                 *\n                 * - `undefined`: Will use the config from `labels.position3d`\n                 *\n                 * @sample highcharts/3d/skewed-labels/\n                 *         Skewed labels\n                 *\n                 * @type     {\"offset\"|\"chart\"|\"flap\"|\"ortho\"|null}\n                 * @since    5.0.15\n                 * @product  highcharts\n                 * @requires highcharts-3d\n                 */\n                position3d: null,\n                /**\n                 * If enabled, the axis title will skewed to follow the perspective.\n                 *\n                 * This will fix overlapping labels and titles, but texts become\n                 * less legible due to the distortion.\n                 *\n                 * The final appearance depends heavily on `title.position3d`.\n                 *\n                 * A `null` value will use the config from `labels.skew3d`.\n                 *\n                 * @sample highcharts/3d/skewed-labels/\n                 *         Skewed labels\n                 *\n                 * @type     {boolean|null}\n                 * @since    5.0.15\n                 * @product  highcharts\n                 * @requires highcharts-3d\n                 */\n                skew3d: null\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Axis3DDefaults;\n    });\n    _registerModule(_modules, 'Core/Axis/Tick3DComposition.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extenstion for 3d axes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, extend, wrap } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(TickClass) {\n            if (U.pushUnique(composedMembers, TickClass)) {\n                addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                wrap(TickClass.prototype, 'getMarkPath', wrapTickGetMarkPath);\n            }\n        }\n        /**\n         * @private\n         */\n        function onTickAfterGetLabelPosition(e) {\n            const axis3D = this.axis.axis3D;\n            if (axis3D) {\n                extend(e.pos, axis3D.fix3dPosition(e.pos));\n            }\n        }\n        /**\n         * @private\n         */\n        function wrapTickGetMarkPath(proceed) {\n            const axis3D = this.axis.axis3D, path = proceed.apply(this, [].slice.call(arguments, 1));\n            if (axis3D) {\n                const start = path[0];\n                const end = path[1];\n                if (start[0] === 'M' && end[0] === 'L') {\n                    const pArr = [\n                        axis3D.fix3dPosition({ x: start[1], y: start[2], z: 0 }),\n                        axis3D.fix3dPosition({ x: end[1], y: end[2], z: 0 })\n                    ];\n                    return this.axis.chart.renderer.toLineSegments(pArr);\n                }\n            }\n            return path;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const Tick3DAdditions = {\n            compose\n        };\n\n        return Tick3DAdditions;\n    });\n    _registerModule(_modules, 'Core/Axis/Axis3DComposition.js', [_modules['Core/Axis/Axis3DDefaults.js'], _modules['Core/Globals.js'], _modules['Core/Math3D.js'], _modules['Core/Axis/Tick3DComposition.js'], _modules['Core/Utilities.js']], function (Axis3DDefaults, H, Math3D, Tick3D, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extenstion for 3d axes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { deg2rad } = H;\n        const { perspective, perspective3D, shapeArea } = Math3D;\n        const { addEvent, merge, pick, wrap } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function onAxisAfterSetOptions() {\n            const axis = this, chart = axis.chart, options = axis.options;\n            if (chart.is3d && chart.is3d() && axis.coll !== 'colorAxis') {\n                options.tickWidth = pick(options.tickWidth, 0);\n                options.gridLineWidth = pick(options.gridLineWidth, 1);\n            }\n        }\n        /**\n         * @private\n         */\n        function onAxisDrawCrosshair(e) {\n            const axis = this;\n            if (axis.chart.is3d() &&\n                axis.coll !== 'colorAxis') {\n                if (e.point) {\n                    e.point.crosshairPos = axis.isXAxis ?\n                        e.point.axisXpos :\n                        axis.len - e.point.axisYpos;\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function onAxisInit() {\n            const axis = this;\n            if (!axis.axis3D) {\n                axis.axis3D = new Axis3DAdditions(axis);\n            }\n        }\n        /**\n         * Do not draw axislines in 3D.\n         * @private\n         */\n        function wrapAxisGetLinePath(proceed) {\n            const axis = this;\n            // Do not do this if the chart is not 3D\n            if (!axis.chart.is3d() || axis.coll === 'colorAxis') {\n                return proceed.apply(axis, [].slice.call(arguments, 1));\n            }\n            return [];\n        }\n        /**\n         * @private\n         */\n        function wrapAxisGetPlotBandPath(proceed) {\n            // Do not do this if the chart is not 3D\n            if (!this.chart.is3d() || this.coll === 'colorAxis') {\n                return proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            const args = arguments, from = args[1], to = args[2], path = [], fromPath = this.getPlotLinePath({ value: from }), toPath = this.getPlotLinePath({ value: to });\n            if (fromPath && toPath) {\n                for (let i = 0; i < fromPath.length; i += 2) {\n                    const fromStartSeg = fromPath[i], fromEndSeg = fromPath[i + 1], toStartSeg = toPath[i], toEndSeg = toPath[i + 1];\n                    if (fromStartSeg[0] === 'M' &&\n                        fromEndSeg[0] === 'L' &&\n                        toStartSeg[0] === 'M' &&\n                        toEndSeg[0] === 'L') {\n                        path.push(fromStartSeg, fromEndSeg, toEndSeg, \n                        // lineTo instead of moveTo\n                        ['L', toStartSeg[1], toStartSeg[2]], ['Z']);\n                    }\n                }\n            }\n            return path;\n        }\n        /**\n         * @private\n         */\n        function wrapAxisGetPlotLinePath(proceed) {\n            const axis = this, axis3D = axis.axis3D, chart = axis.chart, path = proceed.apply(axis, [].slice.call(arguments, 1));\n            // Do not do this if the chart is not 3D\n            if (axis.coll === 'colorAxis' ||\n                !chart.chart3d ||\n                !chart.is3d()) {\n                return path;\n            }\n            if (path === null) {\n                return path;\n            }\n            const options3d = chart.options.chart.options3d, d = axis.isZAxis ? chart.plotWidth : options3d.depth, frame = chart.chart3d.frame3d, startSegment = path[0], endSegment = path[1];\n            let pArr, pathSegments = [];\n            if (startSegment[0] === 'M' && endSegment[0] === 'L') {\n                pArr = [\n                    axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: 0 }),\n                    axis3D.swapZ({ x: startSegment[1], y: startSegment[2], z: d }),\n                    axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: 0 }),\n                    axis3D.swapZ({ x: endSegment[1], y: endSegment[2], z: d })\n                ];\n                if (!this.horiz) { // Y-Axis\n                    if (frame.front.visible) {\n                        pathSegments.push(pArr[0], pArr[2]);\n                    }\n                    if (frame.back.visible) {\n                        pathSegments.push(pArr[1], pArr[3]);\n                    }\n                    if (frame.left.visible) {\n                        pathSegments.push(pArr[0], pArr[1]);\n                    }\n                    if (frame.right.visible) {\n                        pathSegments.push(pArr[2], pArr[3]);\n                    }\n                }\n                else if (this.isZAxis) { // Z-Axis\n                    if (frame.left.visible) {\n                        pathSegments.push(pArr[0], pArr[2]);\n                    }\n                    if (frame.right.visible) {\n                        pathSegments.push(pArr[1], pArr[3]);\n                    }\n                    if (frame.top.visible) {\n                        pathSegments.push(pArr[0], pArr[1]);\n                    }\n                    if (frame.bottom.visible) {\n                        pathSegments.push(pArr[2], pArr[3]);\n                    }\n                }\n                else { // X-Axis\n                    if (frame.front.visible) {\n                        pathSegments.push(pArr[0], pArr[2]);\n                    }\n                    if (frame.back.visible) {\n                        pathSegments.push(pArr[1], pArr[3]);\n                    }\n                    if (frame.top.visible) {\n                        pathSegments.push(pArr[0], pArr[1]);\n                    }\n                    if (frame.bottom.visible) {\n                        pathSegments.push(pArr[2], pArr[3]);\n                    }\n                }\n                pathSegments = perspective(pathSegments, this.chart, false);\n            }\n            return chart.renderer.toLineSegments(pathSegments);\n        }\n        /**\n         * Wrap getSlotWidth function to calculate individual width value for each\n         * slot (#8042).\n         * @private\n         */\n        function wrapAxisGetSlotWidth(proceed, tick) {\n            const axis = this, chart = axis.chart, ticks = axis.ticks, gridGroup = axis.gridGroup;\n            if (axis.categories &&\n                chart.frameShapes &&\n                chart.is3d() &&\n                gridGroup &&\n                tick &&\n                tick.label) {\n                const firstGridLine = (gridGroup.element.childNodes[0].getBBox()), frame3DLeft = chart.frameShapes.left.getBBox(), options3d = chart.options.chart.options3d, origin = {\n                    x: chart.plotWidth / 2,\n                    y: chart.plotHeight / 2,\n                    z: options3d.depth / 2,\n                    vd: (pick(options3d.depth, 1) *\n                        pick(options3d.viewDistance, 0))\n                }, tickId = tick.pos, prevTick = ticks[tickId - 1], nextTick = ticks[tickId + 1];\n                let labelPos, prevLabelPos, nextLabelPos;\n                // Check whether the tick is not the first one and previous tick\n                // exists, then calculate position of previous label.\n                if (tickId !== 0 &&\n                    prevTick &&\n                    prevTick.label &&\n                    prevTick.label.xy) {\n                    prevLabelPos = perspective3D({\n                        x: prevTick.label.xy.x,\n                        y: prevTick.label.xy.y,\n                        z: null\n                    }, origin, origin.vd);\n                }\n                // If next label position is defined, then recalculate its position\n                // basing on the perspective.\n                if (nextTick && nextTick.label && nextTick.label.xy) {\n                    nextLabelPos = perspective3D({\n                        x: nextTick.label.xy.x,\n                        y: nextTick.label.xy.y,\n                        z: null\n                    }, origin, origin.vd);\n                }\n                labelPos = {\n                    x: tick.label.xy.x,\n                    y: tick.label.xy.y,\n                    z: null\n                };\n                labelPos = perspective3D(labelPos, origin, origin.vd);\n                // If tick is first one, check whether next label position is\n                // already calculated, then return difference between the first and\n                // the second label. If there is no next label position calculated,\n                // return the difference between the first grid line and left 3d\n                // frame.\n                return Math.abs(prevLabelPos ?\n                    labelPos.x - prevLabelPos.x : nextLabelPos ?\n                    nextLabelPos.x - labelPos.x :\n                    firstGridLine.x - frame3DLeft.x);\n            }\n            return proceed.apply(axis, [].slice.call(arguments, 1));\n        }\n        /**\n         * @private\n         */\n        function wrapAxisGetTitlePosition(proceed) {\n            const pos = proceed.apply(this, [].slice.call(arguments, 1));\n            return this.axis3D ?\n                this.axis3D.fix3dPosition(pos, true) :\n                pos;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Adds 3D support to axes.\n         * @private\n         * @class\n         */\n        class Axis3DAdditions {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Extends axis class with 3D support.\n             * @private\n             */\n            static compose(AxisClass, TickClass) {\n                Tick3D.compose(TickClass);\n                if (U.pushUnique(composedMembers, AxisClass)) {\n                    merge(true, AxisClass.defaultOptions, Axis3DDefaults);\n                    AxisClass.keepProps.push('axis3D');\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);\n                    addEvent(AxisClass, 'drawCrosshair', onAxisDrawCrosshair);\n                    const axisProto = AxisClass.prototype;\n                    wrap(axisProto, 'getLinePath', wrapAxisGetLinePath);\n                    wrap(axisProto, 'getPlotBandPath', wrapAxisGetPlotBandPath);\n                    wrap(axisProto, 'getPlotLinePath', wrapAxisGetPlotLinePath);\n                    wrap(axisProto, 'getSlotWidth', wrapAxisGetSlotWidth);\n                    wrap(axisProto, 'getTitlePosition', wrapAxisGetTitlePosition);\n                }\n            }\n            /* *\n             *\n             *  Constructors\n             *\n             * */\n            /**\n             * @private\n             */\n            constructor(axis) {\n                this.axis = axis;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             * @param {Highcharts.Axis} axis\n             * Related axis.\n             * @param {Highcharts.Position3DObject} pos\n             * Position to fix.\n             * @param {boolean} [isTitle]\n             * Whether this is a title position.\n             * @return {Highcharts.Position3DObject}\n             * Fixed position.\n             */\n            fix3dPosition(pos, isTitle) {\n                const axis3D = this;\n                const axis = axis3D.axis;\n                const chart = axis.chart;\n                // Do not do this if the chart is not 3D\n                if (axis.coll === 'colorAxis' ||\n                    !chart.chart3d ||\n                    !chart.is3d()) {\n                    return pos;\n                }\n                const alpha = deg2rad * chart.options.chart.options3d.alpha, beta = deg2rad * chart.options.chart.options3d.beta, positionMode = pick(isTitle && axis.options.title.position3d, axis.options.labels.position3d), skew = pick(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d), frame = chart.chart3d.frame3d, plotLeft = chart.plotLeft, plotRight = chart.plotWidth + plotLeft, plotTop = chart.plotTop, plotBottom = chart.plotHeight + plotTop;\n                let offsetX = 0, offsetY = 0, vecX, vecY = { x: 0, y: 1, z: 0 }, \n                // Indicates that we are labelling an X or Z axis on the \"back\" of\n                // the chart\n                reverseFlap = false;\n                pos = axis.axis3D.swapZ({ x: pos.x, y: pos.y, z: 0 });\n                if (axis.isZAxis) { // Z Axis\n                    if (axis.opposite) {\n                        if (frame.axes.z.top === null) {\n                            return {};\n                        }\n                        offsetY = pos.y - plotTop;\n                        pos.x = frame.axes.z.top.x;\n                        pos.y = frame.axes.z.top.y;\n                        vecX = frame.axes.z.top.xDir;\n                        reverseFlap = !frame.top.frontFacing;\n                    }\n                    else {\n                        if (frame.axes.z.bottom === null) {\n                            return {};\n                        }\n                        offsetY = pos.y - plotBottom;\n                        pos.x = frame.axes.z.bottom.x;\n                        pos.y = frame.axes.z.bottom.y;\n                        vecX = frame.axes.z.bottom.xDir;\n                        reverseFlap = !frame.bottom.frontFacing;\n                    }\n                }\n                else if (axis.horiz) { // X Axis\n                    if (axis.opposite) {\n                        if (frame.axes.x.top === null) {\n                            return {};\n                        }\n                        offsetY = pos.y - plotTop;\n                        pos.y = frame.axes.x.top.y;\n                        pos.z = frame.axes.x.top.z;\n                        vecX = frame.axes.x.top.xDir;\n                        reverseFlap = !frame.top.frontFacing;\n                    }\n                    else {\n                        if (frame.axes.x.bottom === null) {\n                            return {};\n                        }\n                        offsetY = pos.y - plotBottom;\n                        pos.y = frame.axes.x.bottom.y;\n                        pos.z = frame.axes.x.bottom.z;\n                        vecX = frame.axes.x.bottom.xDir;\n                        reverseFlap = !frame.bottom.frontFacing;\n                    }\n                }\n                else { // Y Axis\n                    if (axis.opposite) {\n                        if (frame.axes.y.right === null) {\n                            return {};\n                        }\n                        offsetX = pos.x - plotRight;\n                        pos.x = frame.axes.y.right.x;\n                        pos.z = frame.axes.y.right.z;\n                        vecX = frame.axes.y.right.xDir;\n                        // Rotate 90º on opposite edge\n                        vecX = { x: vecX.z, y: vecX.y, z: -vecX.x };\n                    }\n                    else {\n                        if (frame.axes.y.left === null) {\n                            return {};\n                        }\n                        offsetX = pos.x - plotLeft;\n                        pos.x = frame.axes.y.left.x;\n                        pos.z = frame.axes.y.left.z;\n                        vecX = frame.axes.y.left.xDir;\n                    }\n                }\n                if (positionMode === 'chart') {\n                    // Labels preserve their direction relative to the chart\n                    // nothing to do\n                }\n                else if (positionMode === 'flap') {\n                    // Labels are rotated around the axis direction to face the screen\n                    if (!axis.horiz) { // Y Axis\n                        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n                    }\n                    else { // X and Z Axis\n                        let sin = Math.sin(alpha);\n                        const cos = Math.cos(alpha);\n                        if (axis.opposite) {\n                            sin = -sin;\n                        }\n                        if (reverseFlap) {\n                            sin = -sin;\n                        }\n                        vecY = { x: vecX.z * sin, y: cos, z: -vecX.x * sin };\n                    }\n                }\n                else if (positionMode === 'ortho') {\n                    // Labels will be rotated to be ortogonal to the axis\n                    if (!axis.horiz) { // Y Axis\n                        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n                    }\n                    else { // X and Z Axis\n                        const sina = Math.sin(alpha);\n                        const cosa = Math.cos(alpha);\n                        const sinb = Math.sin(beta);\n                        const cosb = Math.cos(beta);\n                        const vecZ = { x: sinb * cosa, y: -sina, z: -cosa * cosb };\n                        vecY = {\n                            x: vecX.y * vecZ.z - vecX.z * vecZ.y,\n                            y: vecX.z * vecZ.x - vecX.x * vecZ.z,\n                            z: vecX.x * vecZ.y - vecX.y * vecZ.x\n                        };\n                        let scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);\n                        if (reverseFlap) {\n                            scale = -scale;\n                        }\n                        vecY = {\n                            x: scale * vecY.x, y: scale * vecY.y, z: scale * vecY.z\n                        };\n                    }\n                }\n                else { // positionMode  == 'offset'\n                    // Labels will be skewd to maintain vertical / horizontal offsets\n                    // from axis\n                    if (!axis.horiz) { // Y Axis\n                        vecX = { x: Math.cos(beta), y: 0, z: Math.sin(beta) };\n                    }\n                    else { // X and Z Axis\n                        vecY = {\n                            x: Math.sin(beta) * Math.sin(alpha),\n                            y: Math.cos(alpha),\n                            z: -Math.cos(beta) * Math.sin(alpha)\n                        };\n                    }\n                }\n                pos.x += offsetX * vecX.x + offsetY * vecY.x;\n                pos.y += offsetX * vecX.y + offsetY * vecY.y;\n                pos.z += offsetX * vecX.z + offsetY * vecY.z;\n                const projected = perspective([pos], axis.chart)[0];\n                if (skew) {\n                    // Check if the label text would be mirrored\n                    const isMirrored = shapeArea(perspective([\n                        pos,\n                        { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },\n                        { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }\n                    ], axis.chart)) < 0;\n                    if (isMirrored) {\n                        vecX = { x: -vecX.x, y: -vecX.y, z: -vecX.z };\n                    }\n                    const pointsProjected = perspective([\n                        { x: pos.x, y: pos.y, z: pos.z },\n                        { x: pos.x + vecX.x, y: pos.y + vecX.y, z: pos.z + vecX.z },\n                        { x: pos.x + vecY.x, y: pos.y + vecY.y, z: pos.z + vecY.z }\n                    ], axis.chart);\n                    projected.matrix = [\n                        pointsProjected[1].x - pointsProjected[0].x,\n                        pointsProjected[1].y - pointsProjected[0].y,\n                        pointsProjected[2].x - pointsProjected[0].x,\n                        pointsProjected[2].y - pointsProjected[0].y,\n                        projected.x,\n                        projected.y\n                    ];\n                    projected.matrix[4] -= projected.x * projected.matrix[0] +\n                        projected.y * projected.matrix[2];\n                    projected.matrix[5] -= projected.x * projected.matrix[1] +\n                        projected.y * projected.matrix[3];\n                }\n                return projected;\n            }\n            /**\n             * @private\n             */\n            swapZ(p, insidePlotArea) {\n                const axis = this.axis;\n                if (axis.isZAxis) {\n                    const plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;\n                    return {\n                        x: plotLeft + p.z,\n                        y: p.y,\n                        z: p.x - plotLeft\n                    };\n                }\n                return p;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Axis3DAdditions;\n    });\n    _registerModule(_modules, 'Core/Series/Series3D.js', [_modules['Core/Math3D.js'], _modules['Core/Series/Series.js'], _modules['Core/Utilities.js']], function (Math3D, Series, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extension to the Series object in 3D charts.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { perspective } = Math3D;\n        const { addEvent, extend, merge, pick, pushUnique, isNumber } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class Series3D extends Series {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(SeriesClass) {\n                if (pushUnique(composedMembers, SeriesClass)) {\n                    addEvent(SeriesClass, 'afterTranslate', function () {\n                        if (this.chart.is3d()) {\n                            this.translate3dPoints();\n                        }\n                    });\n                    extend(SeriesClass.prototype, {\n                        translate3dPoints: Series3D.prototype.translate3dPoints\n                    });\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Translate the plotX, plotY properties and add plotZ.\n             * @private\n             */\n            translate3dPoints() {\n                const series = this, seriesOptions = series.options, chart = series.chart, zAxis = pick(series.zAxis, chart.options.zAxis[0]), rawPoints = [], rawPointsX = [], stack = seriesOptions.stacking ?\n                    (isNumber(seriesOptions.stack) ? seriesOptions.stack : 0) :\n                    series.index || 0;\n                let rawPoint, projectedPoint, zValue, i;\n                series.zPadding = stack *\n                    (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));\n                for (i = 0; i < series.data.length; i++) {\n                    rawPoint = series.data[i];\n                    if (zAxis && zAxis.translate) {\n                        zValue = zAxis.logarithmic && zAxis.val2lin ?\n                            zAxis.val2lin(rawPoint.z) :\n                            rawPoint.z; // #4562\n                        rawPoint.plotZ = zAxis.translate(zValue);\n                        rawPoint.isInside = rawPoint.isInside ?\n                            (zValue >= zAxis.min &&\n                                zValue <= zAxis.max) :\n                            false;\n                    }\n                    else {\n                        rawPoint.plotZ = series.zPadding;\n                    }\n                    rawPoint.axisXpos = rawPoint.plotX;\n                    rawPoint.axisYpos = rawPoint.plotY;\n                    rawPoint.axisZpos = rawPoint.plotZ;\n                    rawPoints.push({\n                        x: rawPoint.plotX,\n                        y: rawPoint.plotY,\n                        z: rawPoint.plotZ\n                    });\n                    rawPointsX.push(rawPoint.plotX || 0);\n                }\n                series.rawPointsX = rawPointsX;\n                const projectedPoints = perspective(rawPoints, chart, true);\n                for (i = 0; i < series.data.length; i++) {\n                    rawPoint = series.data[i];\n                    projectedPoint = projectedPoints[i];\n                    rawPoint.plotX = projectedPoint.x;\n                    rawPoint.plotY = projectedPoint.y;\n                    rawPoint.plotZ = projectedPoint.z;\n                }\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        Series3D.defaultOptions = merge(Series.defaultOptions);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Series3D;\n    });\n    _registerModule(_modules, 'Core/Renderer/SVG/SVGElement3D.js', [_modules['Core/Color/Color.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Utilities.js']], function (Color, RendererRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extensions to the SVGRenderer class to enable 3D shapes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { parse: color } = Color;\n        const { Element: SVGElement } = RendererRegistry.getRendererType().prototype;\n        const { defined, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class SVGElement3D extends SVGElement {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.parts = ['front', 'top', 'side'];\n                this.pathType = 'cuboid';\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * The init is used by base - renderer.Element\n             * @private\n             */\n            initArgs(args) {\n                const elem3d = this, renderer = elem3d.renderer, paths = renderer[elem3d.pathType + 'Path'](args), zIndexes = paths.zIndexes;\n                // build parts\n                for (const part of elem3d.parts) {\n                    const attribs = {\n                        'class': 'highcharts-3d-' + part,\n                        zIndex: zIndexes[part] || 0\n                    };\n                    if (renderer.styledMode) {\n                        if (part === 'top') {\n                            attribs.filter = 'url(#highcharts-brighter)';\n                        }\n                        else if (part === 'side') {\n                            attribs.filter = 'url(#highcharts-darker)';\n                        }\n                    }\n                    elem3d[part] = renderer.path(paths[part])\n                        .attr(attribs)\n                        .add(elem3d);\n                }\n                elem3d.attr({\n                    'stroke-linejoin': 'round',\n                    zIndex: zIndexes.group\n                });\n                // Store information if any side of element was rendered by force.\n                elem3d.forcedSides = paths.forcedSides;\n            }\n            /**\n             * Single property setter that applies options to each part\n             * @private\n             */\n            singleSetterForParts(prop, val, values, verb, duration, complete) {\n                const elem3d = this, newAttr = {}, optionsToApply = [null, null, (verb || 'attr'), duration, complete], hasZIndexes = values && values.zIndexes;\n                if (!values) {\n                    newAttr[prop] = val;\n                    optionsToApply[0] = newAttr;\n                }\n                else {\n                    // It is needed to deal with the whole group zIndexing\n                    // in case of graph rotation\n                    if (hasZIndexes && hasZIndexes.group) {\n                        elem3d.attr({\n                            zIndex: hasZIndexes.group\n                        });\n                    }\n                    for (const part of Object.keys(values)) {\n                        newAttr[part] = {};\n                        newAttr[part][prop] = values[part];\n                        // include zIndexes if provided\n                        if (hasZIndexes) {\n                            newAttr[part].zIndex = values.zIndexes[part] || 0;\n                        }\n                    }\n                    optionsToApply[1] = newAttr;\n                }\n                return this.processParts.apply(elem3d, optionsToApply);\n            }\n            /**\n             * Calls function for each part. Used for attr, animate and destroy.\n             * @private\n             */\n            processParts(props, partsProps, verb, duration, complete) {\n                const elem3d = this;\n                for (const part of elem3d.parts) {\n                    // if different props for different parts\n                    if (partsProps) {\n                        props = pick(partsProps[part], false);\n                    }\n                    // only if something to set, but allow undefined\n                    if (props !== false) {\n                        elem3d[part][verb](props, duration, complete);\n                    }\n                }\n                return elem3d;\n            }\n            /**\n             * Destroy all parts\n             * @private\n             */\n            destroy() {\n                this.processParts(null, null, 'destroy');\n                return super.destroy();\n            }\n            // Following functions are SVGElement3DCuboid (= base)\n            attr(args, val, complete, continueAnimation) {\n                // Resolve setting attributes by string name\n                if (typeof args === 'string' && typeof val !== 'undefined') {\n                    const key = args;\n                    args = {};\n                    args[key] = val;\n                }\n                if (args.shapeArgs || defined(args.x)) {\n                    return this.singleSetterForParts('d', null, this.renderer[this.pathType + 'Path'](args.shapeArgs || args));\n                }\n                return super.attr(args, void 0, complete, continueAnimation);\n            }\n            animate(args, duration, complete) {\n                if (defined(args.x) && defined(args.y)) {\n                    const paths = this.renderer[this.pathType + 'Path'](args), forcedSides = paths.forcedSides;\n                    this.singleSetterForParts('d', null, paths, 'animate', duration, complete);\n                    this.attr({\n                        zIndex: paths.zIndexes.group\n                    });\n                    // If sides that are forced to render changed, recalculate colors.\n                    if (forcedSides !== this.forcedSides) {\n                        this.forcedSides = forcedSides;\n                        if (!this.renderer.styledMode) {\n                            this.fillSetter(this.fill);\n                        }\n                    }\n                }\n                else {\n                    super.animate(args, duration, complete);\n                }\n                return this;\n            }\n            fillSetter(fill) {\n                const elem3d = this;\n                elem3d.forcedSides = elem3d.forcedSides || [];\n                elem3d.singleSetterForParts('fill', null, {\n                    front: fill,\n                    // Do not change color if side was forced to render.\n                    top: color(fill).brighten(elem3d.forcedSides.indexOf('top') >= 0 ? 0 : 0.1).get(),\n                    side: color(fill).brighten(elem3d.forcedSides.indexOf('side') >= 0 ? 0 : -0.1).get()\n                });\n                // fill for animation getter (#6776)\n                elem3d.color = elem3d.fill = fill;\n                return elem3d;\n            }\n        }\n        SVGElement3D.types = {\n            base: SVGElement3D,\n            cuboid: SVGElement3D\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SVGElement3D;\n    });\n    _registerModule(_modules, 'Core/Renderer/SVG/SVGRenderer3D.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Math3D.js'], _modules['Core/Renderer/SVG/SVGElement3D.js'], _modules['Core/Utilities.js']], function (A, Color, H, Math3D, SVGElement3D, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Extensions to the SVGRenderer class to enable 3D shapes\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { animObject } = A;\n        const { parse: color } = Color;\n        const { charts, deg2rad } = H;\n        const { perspective, shapeArea } = Math3D;\n        const { defined, extend, merge, pick, pushUnique } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [], cos = Math.cos, sin = Math.sin, PI = Math.PI, dFactor = (4 * (Math.sqrt(2) - 1) / 3) / (PI / 2);\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Method to construct a curved path. Can 'wrap' around more then 180\n         * degrees.\n         * @private\n         */\n        function curveTo(cx, cy, rx, ry, start, end, dx, dy) {\n            const arcAngle = end - start;\n            let result = [];\n            if ((end > start) && (end - start > Math.PI / 2 + 0.0001)) {\n                result = result.concat(curveTo(cx, cy, rx, ry, start, start + (Math.PI / 2), dx, dy));\n                result = result.concat(curveTo(cx, cy, rx, ry, start + (Math.PI / 2), end, dx, dy));\n                return result;\n            }\n            if ((end < start) && (start - end > Math.PI / 2 + 0.0001)) {\n                result = result.concat(curveTo(cx, cy, rx, ry, start, start - (Math.PI / 2), dx, dy));\n                result = result.concat(curveTo(cx, cy, rx, ry, start - (Math.PI / 2), end, dx, dy));\n                return result;\n            }\n            return [[\n                    'C',\n                    cx + (rx * Math.cos(start)) -\n                        ((rx * dFactor * arcAngle) * Math.sin(start)) + dx,\n                    cy + (ry * Math.sin(start)) +\n                        ((ry * dFactor * arcAngle) * Math.cos(start)) + dy,\n                    cx + (rx * Math.cos(end)) +\n                        ((rx * dFactor * arcAngle) * Math.sin(end)) + dx,\n                    cy + (ry * Math.sin(end)) -\n                        ((ry * dFactor * arcAngle) * Math.cos(end)) + dy,\n                    cx + (rx * Math.cos(end)) + dx,\n                    cy + (ry * Math.sin(end)) + dy\n                ]];\n        }\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var SVGRenderer3D;\n        (function (SVGRenderer3D) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function compose(SVGRendererClass) {\n                if (pushUnique(composedMembers, SVGRendererClass)) {\n                    extend(SVGRendererClass.prototype, {\n                        Element3D: SVGElement3D,\n                        arc3d,\n                        arc3dPath,\n                        cuboid,\n                        cuboidPath,\n                        element3d,\n                        face3d,\n                        polyhedron,\n                        toLinePath,\n                        toLineSegments\n                    });\n                }\n            }\n            SVGRenderer3D.compose = compose;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /** @private */\n            function toLinePath(points, closed) {\n                const result = [];\n                // Put \"L x y\" for each point\n                for (const point of points) {\n                    result.push(['L', point.x, point.y]);\n                }\n                if (points.length) {\n                    // Set the first element to M\n                    result[0][0] = 'M';\n                    // If it is a closed line, add Z\n                    if (closed) {\n                        result.push(['Z']);\n                    }\n                }\n                return result;\n            }\n            /** @private */\n            function toLineSegments(points) {\n                const result = [];\n                let m = true;\n                for (const point of points) {\n                    result.push(m ? ['M', point.x, point.y] : ['L', point.x, point.y]);\n                    m = !m;\n                }\n                return result;\n            }\n            /**\n             * A 3-D Face is defined by it's 3D vertexes, and is only visible if it's\n             * vertexes are counter-clockwise (Back-face culling). It is used as a\n             * polyhedron Element.\n             * @private\n             */\n            function face3d(args) {\n                const renderer = this, elementProto = renderer.Element.prototype, ret = renderer.createElement('path');\n                ret.vertexes = [];\n                ret.insidePlotArea = false;\n                ret.enabled = true;\n                /* eslint-disable no-invalid-this */\n                ret.attr = function (hash) {\n                    if (typeof hash === 'object' &&\n                        (defined(hash.enabled) ||\n                            defined(hash.vertexes) ||\n                            defined(hash.insidePlotArea))) {\n                        this.enabled = pick(hash.enabled, this.enabled);\n                        this.vertexes = pick(hash.vertexes, this.vertexes);\n                        this.insidePlotArea = pick(hash.insidePlotArea, this.insidePlotArea);\n                        delete hash.enabled;\n                        delete hash.vertexes;\n                        delete hash.insidePlotArea;\n                        const chart = charts[renderer.chartIndex], vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea(vertexes2d);\n                        hash.d = path;\n                        hash.visibility = (this.enabled && area > 0) ?\n                            'inherit' : 'hidden';\n                    }\n                    return elementProto.attr.apply(this, arguments);\n                };\n                ret.animate = function (params) {\n                    if (typeof params === 'object' &&\n                        (defined(params.enabled) ||\n                            defined(params.vertexes) ||\n                            defined(params.insidePlotArea))) {\n                        this.enabled = pick(params.enabled, this.enabled);\n                        this.vertexes = pick(params.vertexes, this.vertexes);\n                        this.insidePlotArea = pick(params.insidePlotArea, this.insidePlotArea);\n                        delete params.enabled;\n                        delete params.vertexes;\n                        delete params.insidePlotArea;\n                        const chart = charts[renderer.chartIndex], vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea), path = renderer.toLinePath(vertexes2d, true), area = shapeArea(vertexes2d), visibility = (this.enabled && area > 0) ?\n                            'visible' : 'hidden';\n                        params.d = path;\n                        this.attr('visibility', visibility);\n                    }\n                    return elementProto.animate.apply(this, arguments);\n                };\n                /* eslint-enable no-invalid-this */\n                return ret.attr(args);\n            }\n            /**\n             * A Polyhedron is a handy way of defining a group of 3-D faces. It's only\n             * attribute is `faces`, an array of attributes of each one of it's Face3D\n             * instances.\n             * @private\n             */\n            function polyhedron(args) {\n                const renderer = this, elementProto = renderer.Element.prototype, result = renderer.g(), destroy = result.destroy;\n                if (!this.styledMode) {\n                    result.attr({\n                        'stroke-linejoin': 'round'\n                    });\n                }\n                result.faces = [];\n                // destroy all children\n                result.destroy = function () {\n                    for (let i = 0; i < result.faces.length; i++) {\n                        result.faces[i].destroy();\n                    }\n                    return destroy.call(this);\n                };\n                result.attr = function (hash, val, complete, continueAnimation) {\n                    if (typeof hash === 'object' && defined(hash.faces)) {\n                        while (result.faces.length > hash.faces.length) {\n                            result.faces.pop().destroy();\n                        }\n                        while (result.faces.length < hash.faces.length) {\n                            result.faces.push(renderer.face3d().add(result));\n                        }\n                        for (let i = 0; i < hash.faces.length; i++) {\n                            if (renderer.styledMode) {\n                                delete hash.faces[i].fill;\n                            }\n                            result.faces[i].attr(hash.faces[i], null, complete, continueAnimation);\n                        }\n                        delete hash.faces;\n                    }\n                    return elementProto.attr.apply(this, arguments);\n                };\n                result.animate = function (params, duration, complete) {\n                    if (params && params.faces) {\n                        while (result.faces.length > params.faces.length) {\n                            result.faces.pop().destroy();\n                        }\n                        while (result.faces.length < params.faces.length) {\n                            result.faces.push(renderer.face3d().add(result));\n                        }\n                        for (let i = 0; i < params.faces.length; i++) {\n                            result.faces[i].animate(params.faces[i], duration, complete);\n                        }\n                        delete params.faces;\n                    }\n                    return elementProto.animate.apply(this, arguments);\n                };\n                return result.attr(args);\n            }\n            /**\n             * return result, generalization\n             * @private\n             * @requires highcharts-3d\n             */\n            function element3d(type, shapeArgs) {\n                // base\n                const elem3d = new SVGElement3D.types[type]();\n                // init\n                elem3d.init(this, 'g');\n                elem3d.initArgs(shapeArgs);\n                // return\n                return elem3d;\n            }\n            /**\n             * generelized, so now use simply\n             * @private\n             */\n            function cuboid(shapeArgs) {\n                return this.element3d('cuboid', shapeArgs);\n            }\n            /**\n             * Generates a cuboid path and zIndexes\n             * @private\n             */\n            function cuboidPath(shapeArgs) {\n                const x = shapeArgs.x || 0, y = shapeArgs.y || 0, z = shapeArgs.z || 0, \n                // For side calculation (right/left)\n                // there is a need for height (and other shapeArgs arguments)\n                // to be at least 1px\n                h = shapeArgs.height || 0, w = shapeArgs.width || 0, d = shapeArgs.depth || 0, chart = charts[this.chartIndex], options3d = chart.options.chart.options3d, alpha = options3d.alpha, \n                // Priority for x axis is the biggest,\n                // because of x direction has biggest influence on zIndex\n                incrementX = 1000000, \n                // y axis has the smallest priority in case of our charts\n                // (needs to be set because of stacking)\n                incrementY = 10, incrementZ = 100, forcedSides = [];\n                let shape, zIndex = 0, \n                // The 8 corners of the cube\n                pArr = [{\n                        x: x,\n                        y: y,\n                        z: z\n                    }, {\n                        x: x + w,\n                        y: y,\n                        z: z\n                    }, {\n                        x: x + w,\n                        y: y + h,\n                        z: z\n                    }, {\n                        x: x,\n                        y: y + h,\n                        z: z\n                    }, {\n                        x: x,\n                        y: y + h,\n                        z: z + d\n                    }, {\n                        x: x + w,\n                        y: y + h,\n                        z: z + d\n                    }, {\n                        x: x + w,\n                        y: y,\n                        z: z + d\n                    }, {\n                        x: x,\n                        y: y,\n                        z: z + d\n                    }];\n                // apply perspective\n                pArr = perspective(pArr, chart, shapeArgs.insidePlotArea);\n                /**\n                 * helper method to decide which side is visible\n                 * @private\n                 */\n                const mapSidePath = (i) => {\n                    // Added support for 0 value in columns, where height is 0\n                    // but the shape is rendered.\n                    // Height is used from 1st to 6th element of pArr\n                    if (h === 0 && i > 1 && i < 6) { // [2, 3, 4, 5]\n                        return {\n                            x: pArr[i].x,\n                            // when height is 0 instead of cuboid we render plane\n                            // so it is needed to add fake 10 height to imitate\n                            // cuboid for side calculation\n                            y: pArr[i].y + 10,\n                            z: pArr[i].z\n                        };\n                    }\n                    // It is needed to calculate dummy sides (front/back) for\n                    // breaking points in case of x and depth values. If column has\n                    // side, it means that x values of front and back side are\n                    // different.\n                    if (pArr[0].x === pArr[7].x && i >= 4) { // [4, 5, 6, 7]\n                        return {\n                            x: pArr[i].x + 10,\n                            // when height is 0 instead of cuboid we render plane\n                            // so it is needed to add fake 10 height to imitate\n                            // cuboid for side calculation\n                            y: pArr[i].y,\n                            z: pArr[i].z\n                        };\n                    }\n                    // Added dummy depth\n                    if (d === 0 && i < 2 || i > 5) { // [0, 1, 6, 7]\n                        return {\n                            x: pArr[i].x,\n                            // when height is 0 instead of cuboid we render plane\n                            // so it is needed to add fake 10 height to imitate\n                            // cuboid for side calculation\n                            y: pArr[i].y,\n                            z: pArr[i].z + 10\n                        };\n                    }\n                    return pArr[i];\n                }, \n                /**\n                 * method creating the final side\n                 * @private\n                 */\n                mapPath = (i) => (pArr[i]), \n                /**\n                 * First value - path with specific face\n                 * Second  value - added info about side for later calculations.\n                 *                 Possible second values are 0 for path1, 1 for\n                 *                 path2 and -1 for no path chosen.\n                 * Third value - string containing information about current side of\n                 *               cuboid for forcing side rendering.\n                 * @private\n                 */\n                pickShape = (verticesIndex1, verticesIndex2, side) => {\n                    const // An array of vertices for cuboid face\n                    face1 = verticesIndex1.map(mapPath), face2 = verticesIndex2.map(mapPath), \n                    // dummy face is calculated the same way as standard face,\n                    // but if cuboid height is 0 additional height is added so\n                    // it is possible to use this vertices array for visible\n                    // face calculation\n                    dummyFace1 = verticesIndex1.map(mapSidePath), dummyFace2 = verticesIndex2.map(mapSidePath);\n                    let ret = [[], -1];\n                    if (shapeArea(face1) < 0) {\n                        ret = [face1, 0];\n                    }\n                    else if (shapeArea(face2) < 0) {\n                        ret = [face2, 1];\n                    }\n                    else if (side) {\n                        forcedSides.push(side);\n                        if (shapeArea(dummyFace1) < 0) {\n                            ret = [face1, 0];\n                        }\n                        else if (shapeArea(dummyFace2) < 0) {\n                            ret = [face2, 1];\n                        }\n                        else {\n                            ret = [face1, 0]; // force side calculation.\n                        }\n                    }\n                    return ret;\n                };\n                // front or back\n                const front = [3, 2, 1, 0], back = [7, 6, 5, 4];\n                shape = pickShape(front, back, 'front');\n                const path1 = shape[0], isFront = shape[1];\n                // top or bottom\n                const top = [1, 6, 7, 0], bottom = [4, 5, 2, 3];\n                shape = pickShape(top, bottom, 'top');\n                const path2 = shape[0], isTop = shape[1];\n                // side\n                const right = [1, 2, 5, 6], left = [0, 7, 4, 3];\n                shape = pickShape(right, left, 'side');\n                const path3 = shape[0], isRight = shape[1];\n                /* New block used for calculating zIndex. It is basing on X, Y and Z\n                position of specific columns. All zIndexes (for X, Y and Z values) are\n                added to the final zIndex, where every value has different priority. The\n                biggest priority is in X and Z directions, the lowest index is for\n                stacked columns (Y direction and the same X and Z positions). Big\n                differences between priorities is made because we need to ensure that\n                even for big changes in Y and Z parameters all columns will be drawn\n                correctly. */\n                if (isRight === 1) {\n                    // It is needed to connect value with current chart width\n                    // for big chart size.\n                    zIndex += incrementX * (chart.plotWidth - x);\n                }\n                else if (!isRight) {\n                    zIndex += incrementX * x;\n                }\n                zIndex += incrementY * (!isTop ||\n                    // Numbers checked empirically\n                    (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ?\n                    chart.plotHeight - y : 10 + y);\n                if (isFront === 1) {\n                    zIndex += incrementZ * (z);\n                }\n                else if (!isFront) {\n                    zIndex += incrementZ * (1000 - z);\n                }\n                return {\n                    front: this.toLinePath(path1, true),\n                    top: this.toLinePath(path2, true),\n                    side: this.toLinePath(path3, true),\n                    zIndexes: {\n                        group: Math.round(zIndex)\n                    },\n                    forcedSides: forcedSides,\n                    // additional info about zIndexes\n                    isFront: isFront,\n                    isTop: isTop\n                }; // #4774\n            }\n            /** @private */\n            function arc3d(attribs) {\n                const renderer = this, wrapper = renderer.g(), elementProto = renderer.Element.prototype, customAttribs = ['x', 'y', 'r', 'innerR', 'start', 'end', 'depth'];\n                /**\n                 * Get custom attributes. Don't mutate the original object and return an\n                 * object with only custom attr.\n                 * @private\n                 */\n                function suckOutCustom(params) {\n                    const ca = {};\n                    let hasCA = false, key;\n                    params = merge(params); // Don't mutate the original object\n                    for (key in params) {\n                        if (customAttribs.indexOf(key) !== -1) {\n                            ca[key] = params[key];\n                            delete params[key];\n                            hasCA = true;\n                        }\n                    }\n                    return hasCA ? [ca, params] : false;\n                }\n                attribs = merge(attribs);\n                attribs.alpha = (attribs.alpha || 0) * deg2rad;\n                attribs.beta = (attribs.beta || 0) * deg2rad;\n                // Create the different sub sections of the shape\n                wrapper.top = renderer.path();\n                wrapper.side1 = renderer.path();\n                wrapper.side2 = renderer.path();\n                wrapper.inn = renderer.path();\n                wrapper.out = renderer.path();\n                /* eslint-disable no-invalid-this */\n                // Add all faces\n                wrapper.onAdd = function () {\n                    const parent = wrapper.parentGroup, className = wrapper.attr('class');\n                    wrapper.top.add(wrapper);\n                    // These faces are added outside the wrapper group because the\n                    // z-index relates to neighbour elements as well\n                    for (const face of ['out', 'inn', 'side1', 'side2']) {\n                        wrapper[face]\n                            .attr({\n                            'class': className + ' highcharts-3d-side'\n                        })\n                            .add(parent);\n                    }\n                };\n                // Cascade to faces\n                for (const fn of ['addClass', 'removeClass']) {\n                    wrapper[fn] = function () {\n                        const args = arguments;\n                        for (const face of ['top', 'out', 'inn', 'side1', 'side2']) {\n                            wrapper[face][fn].apply(wrapper[face], args);\n                        }\n                    };\n                }\n                /**\n                 * Compute the transformed paths and set them to the composite shapes\n                 * @private\n                 */\n                wrapper.setPaths = function (attribs) {\n                    const paths = wrapper.renderer.arc3dPath(attribs), zIndex = paths.zTop * 100;\n                    wrapper.attribs = attribs;\n                    wrapper.top.attr({ d: paths.top, zIndex: paths.zTop });\n                    wrapper.inn.attr({ d: paths.inn, zIndex: paths.zInn });\n                    wrapper.out.attr({ d: paths.out, zIndex: paths.zOut });\n                    wrapper.side1.attr({ d: paths.side1, zIndex: paths.zSide1 });\n                    wrapper.side2.attr({ d: paths.side2, zIndex: paths.zSide2 });\n                    // show all children\n                    wrapper.zIndex = zIndex;\n                    wrapper.attr({ zIndex: zIndex });\n                    // Set the radial gradient center the first time\n                    if (attribs.center) {\n                        wrapper.top.setRadialReference(attribs.center);\n                        delete attribs.center;\n                    }\n                };\n                wrapper.setPaths(attribs);\n                /**\n                 * Apply the fill to the top and a darker shade to the sides\n                 * @private\n                 */\n                wrapper.fillSetter = function (value) {\n                    const darker = color(value).brighten(-0.1).get();\n                    this.fill = value;\n                    this.side1.attr({ fill: darker });\n                    this.side2.attr({ fill: darker });\n                    this.inn.attr({ fill: darker });\n                    this.out.attr({ fill: darker });\n                    this.top.attr({ fill: value });\n                    return this;\n                };\n                // Apply the same value to all. These properties cascade down to the\n                // children when set to the composite arc3d.\n                for (const setter of ['opacity', 'translateX', 'translateY', 'visibility']) {\n                    wrapper[setter + 'Setter'] = function (value, key) {\n                        wrapper[key] = value;\n                        for (const el of ['out', 'inn', 'side1', 'side2', 'top']) {\n                            wrapper[el].attr(key, value);\n                        }\n                    };\n                }\n                // Override attr to remove shape attributes and use those to set child\n                // paths\n                wrapper.attr = function (params) {\n                    let ca, paramArr;\n                    if (typeof params === 'object') {\n                        paramArr = suckOutCustom(params);\n                        if (paramArr) {\n                            ca = paramArr[0];\n                            arguments[0] = paramArr[1];\n                            extend(wrapper.attribs, ca);\n                            wrapper.setPaths(wrapper.attribs);\n                        }\n                    }\n                    return elementProto.attr.apply(wrapper, arguments);\n                };\n                // Override the animate function by sucking out custom parameters\n                // related to the shapes directly, and update the shapes from the\n                // animation step.\n                wrapper.animate = function (params, animation, complete) {\n                    const from = this.attribs, randomProp = ('data-' + Math.random().toString(26).substring(2, 9));\n                    let paramArr, to;\n                    // Attribute-line properties connected to 3D. These shouldn't have\n                    // been in the attribs collection in the first place.\n                    delete params.center;\n                    delete params.z;\n                    delete params.alpha;\n                    delete params.beta;\n                    const anim = animObject(pick(animation, this.renderer.globalAnimation));\n                    if (anim.duration) {\n                        paramArr = suckOutCustom(params);\n                        // Params need to have a property in order for the step to run\n                        // (#5765, #7097, #7437)\n                        wrapper[randomProp] = 0;\n                        params[randomProp] = 1;\n                        wrapper[randomProp + 'Setter'] = H.noop;\n                        if (paramArr) {\n                            to = paramArr[0]; // custom attr\n                            anim.step = function (a, fx) {\n                                const interpolate = (key) => (from[key] + (pick(to[key], from[key]) -\n                                    from[key]) * fx.pos);\n                                if (fx.prop === randomProp) {\n                                    fx.elem.setPaths(merge(from, {\n                                        x: interpolate('x'),\n                                        y: interpolate('y'),\n                                        r: interpolate('r'),\n                                        innerR: interpolate('innerR'),\n                                        start: interpolate('start'),\n                                        end: interpolate('end'),\n                                        depth: interpolate('depth')\n                                    }));\n                                }\n                            };\n                        }\n                        animation = anim; // Only when duration (#5572)\n                    }\n                    return elementProto.animate.call(this, params, animation, complete);\n                };\n                // destroy all children\n                wrapper.destroy = function () {\n                    this.top.destroy();\n                    this.out.destroy();\n                    this.inn.destroy();\n                    this.side1.destroy();\n                    this.side2.destroy();\n                    return elementProto.destroy.call(this);\n                };\n                // hide all children\n                wrapper.hide = function () {\n                    this.top.hide();\n                    this.out.hide();\n                    this.inn.hide();\n                    this.side1.hide();\n                    this.side2.hide();\n                };\n                wrapper.show = function (inherit) {\n                    this.top.show(inherit);\n                    this.out.show(inherit);\n                    this.inn.show(inherit);\n                    this.side1.show(inherit);\n                    this.side2.show(inherit);\n                };\n                /* eslint-enable no-invalid-this */\n                return wrapper;\n            }\n            /**\n             * Generate the paths required to draw a 3D arc.\n             * @private\n             */\n            function arc3dPath(shapeArgs) {\n                const cx = shapeArgs.x || 0, // x coordinate of the center\n                cy = shapeArgs.y || 0, // y coordinate of the center\n                start = shapeArgs.start || 0, // start angle\n                end = (shapeArgs.end || 0) - 0.00001, // end angle\n                r = shapeArgs.r || 0, // radius\n                ir = shapeArgs.innerR || 0, // inner radius\n                d = shapeArgs.depth || 0, // depth\n                alpha = shapeArgs.alpha || 0, // alpha rotation of the chart\n                beta = shapeArgs.beta || 0; // beta rotation of the chart\n                // Derived Variables\n                const cs = Math.cos(start), // cosinus of the start angle\n                ss = Math.sin(start), // sinus of the start angle\n                ce = Math.cos(end), // cosinus of the end angle\n                se = Math.sin(end), // sinus of the end angle\n                rx = r * Math.cos(beta), // x-radius\n                ry = r * Math.cos(alpha), // y-radius\n                irx = ir * Math.cos(beta), // x-radius (inner)\n                iry = ir * Math.cos(alpha), // y-radius (inner)\n                dx = d * Math.sin(beta), // distance between top and bottom in x\n                dy = d * Math.sin(alpha); // distance between top and bottom in y\n                // TOP\n                let top = [\n                    ['M', cx + (rx * cs), cy + (ry * ss)]\n                ];\n                top = top.concat(curveTo(cx, cy, rx, ry, start, end, 0, 0));\n                top.push([\n                    'L', cx + (irx * ce), cy + (iry * se)\n                ]);\n                top = top.concat(curveTo(cx, cy, irx, iry, end, start, 0, 0));\n                top.push(['Z']);\n                // OUTSIDE\n                const b = (beta > 0 ? Math.PI / 2 : 0), a = (alpha > 0 ? 0 : Math.PI / 2);\n                const start2 = start > -b ? start : (end > -b ? -b : start), end2 = end < PI - a ? end : (start < PI - a ? PI - a : end), midEnd = 2 * PI - a;\n                // When slice goes over bottom middle, need to add both, left and right\n                // outer side. Additionally, when we cross right hand edge, create sharp\n                // edge. Outer shape/wall:\n                //\n                //            -------\n                //          /    ^    \\\n                //    4)   /   /   \\   \\  1)\n                //        /   /     \\   \\\n                //       /   /       \\   \\\n                // (c)=> ====         ==== <=(d)\n                //       \\   \\       /   /\n                //        \\   \\<=(a)/   /\n                //         \\   \\   /   / <=(b)\n                //    3)    \\    v    /  2)\n                //            -------\n                //\n                // (a) - inner side\n                // (b) - outer side\n                // (c) - left edge (sharp)\n                // (d) - right edge (sharp)\n                // 1..n - rendering order for startAngle = 0, when set to e.g 90, order\n                // changes clockwise (1->2, 2->3, n->1) and counterclockwise for\n                // negative startAngle\n                let out = [\n                    ['M', cx + (rx * cos(start2)), cy + (ry * sin(start2))]\n                ];\n                out = out.concat(curveTo(cx, cy, rx, ry, start2, end2, 0, 0));\n                // When shape is wide, it can cross both, (c) and (d) edges, when using\n                // startAngle\n                if (end > midEnd && start < midEnd) {\n                    // Go to outer side\n                    out.push([\n                        'L', cx + (rx * cos(end2)) + dx, cy + (ry * sin(end2)) + dy\n                    ]);\n                    // Curve to the right edge of the slice (d)\n                    out = out.concat(curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));\n                    // Go to the inner side\n                    out.push([\n                        'L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))\n                    ]);\n                    // Curve to the true end of the slice\n                    out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));\n                    // Go to the outer side\n                    out.push([\n                        'L', cx + (rx * cos(end)) + dx, cy + (ry * sin(end)) + dy\n                    ]);\n                    // Go back to middle (d)\n                    out = out.concat(curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));\n                    out.push([\n                        'L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))\n                    ]);\n                    // Go back to the left edge\n                    out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0));\n                    // But shape can cross also only (c) edge:\n                }\n                else if (end > PI - a && start < PI - a) {\n                    // Go to outer side\n                    out.push([\n                        'L',\n                        cx + (rx * Math.cos(end2)) + dx,\n                        cy + (ry * Math.sin(end2)) + dy\n                    ]);\n                    // Curve to the true end of the slice\n                    out = out.concat(curveTo(cx, cy, rx, ry, end2, end, dx, dy));\n                    // Go to the inner side\n                    out.push([\n                        'L', cx + (rx * Math.cos(end)), cy + (ry * Math.sin(end))\n                    ]);\n                    // Go back to the artifical end2\n                    out = out.concat(curveTo(cx, cy, rx, ry, end, end2, 0, 0));\n                }\n                out.push([\n                    'L',\n                    cx + (rx * Math.cos(end2)) + dx,\n                    cy + (ry * Math.sin(end2)) + dy\n                ]);\n                out = out.concat(curveTo(cx, cy, rx, ry, end2, start2, dx, dy));\n                out.push(['Z']);\n                // INSIDE\n                let inn = [\n                    ['M', cx + (irx * cs), cy + (iry * ss)]\n                ];\n                inn = inn.concat(curveTo(cx, cy, irx, iry, start, end, 0, 0));\n                inn.push([\n                    'L',\n                    cx + (irx * Math.cos(end)) + dx,\n                    cy + (iry * Math.sin(end)) + dy\n                ]);\n                inn = inn.concat(curveTo(cx, cy, irx, iry, end, start, dx, dy));\n                inn.push(['Z']);\n                // SIDES\n                const side1 = [\n                    ['M', cx + (rx * cs), cy + (ry * ss)],\n                    ['L', cx + (rx * cs) + dx, cy + (ry * ss) + dy],\n                    ['L', cx + (irx * cs) + dx, cy + (iry * ss) + dy],\n                    ['L', cx + (irx * cs), cy + (iry * ss)],\n                    ['Z']\n                ];\n                const side2 = [\n                    ['M', cx + (rx * ce), cy + (ry * se)],\n                    ['L', cx + (rx * ce) + dx, cy + (ry * se) + dy],\n                    ['L', cx + (irx * ce) + dx, cy + (iry * se) + dy],\n                    ['L', cx + (irx * ce), cy + (iry * se)],\n                    ['Z']\n                ];\n                // correction for changed position of vanishing point caused by alpha\n                // and beta rotations\n                const angleCorr = Math.atan2(dy, -dx);\n                let angleEnd = Math.abs(end + angleCorr), angleStart = Math.abs(start + angleCorr), angleMid = Math.abs((start + end) / 2 + angleCorr);\n                /**\n                 * set to 0-PI range\n                 * @private\n                 */\n                function toZeroPIRange(angle) {\n                    angle = angle % (2 * Math.PI);\n                    if (angle > Math.PI) {\n                        angle = 2 * Math.PI - angle;\n                    }\n                    return angle;\n                }\n                angleEnd = toZeroPIRange(angleEnd);\n                angleStart = toZeroPIRange(angleStart);\n                angleMid = toZeroPIRange(angleMid);\n                // *1e5 is to compensate pInt in zIndexSetter\n                const incPrecision = 1e5, a1 = angleMid * incPrecision, a2 = angleStart * incPrecision, a3 = angleEnd * incPrecision;\n                return {\n                    top: top,\n                    // max angle is PI, so this is always higher\n                    zTop: Math.PI * incPrecision + 1,\n                    out: out,\n                    zOut: Math.max(a1, a2, a3),\n                    inn: inn,\n                    zInn: Math.max(a1, a2, a3),\n                    side1: side1,\n                    // to keep below zOut and zInn in case of same values\n                    zSide1: a3 * 0.99,\n                    side2: side2,\n                    zSide2: a2 * 0.99\n                };\n            }\n        })(SVGRenderer3D || (SVGRenderer3D = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SVGRenderer3D;\n    });\n    _registerModule(_modules, 'Core/Axis/ZAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Utilities.js']], function (Axis, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, merge, pick, splat } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function chartAddZAxis(options) {\n            return new ZAxis(this, options);\n        }\n        /**\n         * Get the Z axis in addition to the default X and Y.\n         * @private\n         */\n        function onChartAfterGetAxes() {\n            const zAxisOptions = this.options.zAxis = splat(this.options.zAxis || {});\n            if (!this.is3d()) {\n                return;\n            }\n            this.zAxis = [];\n            zAxisOptions.forEach((axisOptions, i) => {\n                this.addZAxis(axisOptions).setScale();\n            });\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * 3D axis for z coordinates.\n         */\n        class ZAxis extends Axis {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                this.isZAxis = true;\n            }\n            static compose(ChartClass) {\n                if (U.pushUnique(composedMembers, ChartClass)) {\n                    addEvent(ChartClass, 'afterGetAxes', onChartAfterGetAxes);\n                    const chartProto = ChartClass.prototype;\n                    chartProto.addZAxis = chartAddZAxis;\n                    chartProto.collectionsWithInit.zAxis = [chartProto.addZAxis];\n                    chartProto.collectionsWithUpdate.push('zAxis');\n                }\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            init(chart, userOptions) {\n                // #14793, this used to be set on the prototype\n                this.isZAxis = true;\n                super.init(chart, userOptions, 'zAxis');\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            getSeriesExtremes() {\n                const chart = this.chart;\n                this.hasVisibleSeries = false;\n                // Reset properties in case we're redrawing (#3353)\n                this.dataMin = this.dataMax = this.ignoreMinPadding = (this.ignoreMaxPadding = void 0);\n                if (this.stacking) {\n                    this.stacking.buildStacks();\n                }\n                // loop through this axis' series\n                this.series.forEach((series) => {\n                    if (series.reserveSpace()) {\n                        let threshold = series.options.threshold;\n                        this.hasVisibleSeries = true;\n                        // Validate threshold in logarithmic axes\n                        if (this.positiveValuesOnly && threshold <= 0) {\n                            threshold = void 0;\n                        }\n                        const zData = series.zData;\n                        if (zData.length) {\n                            this.dataMin = Math.min(pick(this.dataMin, zData[0]), Math.min.apply(null, zData));\n                            this.dataMax = Math.max(pick(this.dataMax, zData[0]), Math.max.apply(null, zData));\n                        }\n                    }\n                });\n            }\n            /**\n             * @private\n             */\n            setAxisSize() {\n                const chart = this.chart;\n                super.setAxisSize();\n                this.width = this.len = (chart.options.chart.options3d &&\n                    chart.options.chart.options3d.depth) || 0;\n                this.right = chart.chartWidth - this.width - this.left;\n            }\n            /**\n             * @private\n             */\n            setOptions(userOptions) {\n                userOptions = merge({\n                    offset: 0,\n                    lineWidth: 0\n                }, userOptions);\n                super.setOptions(userOptions);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ZAxis;\n    });\n    _registerModule(_modules, 'Series/Column3D/Column3DComposition.js', [_modules['Core/Math3D.js'], _modules['Core/Utilities.js']], function (Math3D, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { perspective } = Math3D;\n        const { addEvent, extend, pick, pushUnique, wrap } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /** @private */\n        function columnSeriesTranslate3dShapes() {\n            const series = this, chart = series.chart, seriesOptions = series.options, depth = seriesOptions.depth, stack = seriesOptions.stacking ?\n                (seriesOptions.stack || 0) :\n                series.index; // #4743\n            let z = stack * (depth + (seriesOptions.groupZPadding || 1)), borderCrisp = series.borderWidth % 2 ? 0.5 : 0, point2dPos; // Position of point in 2D, used for 3D position calculation\n            if (chart.inverted && !series.yAxis.reversed) {\n                borderCrisp *= -1;\n            }\n            if (seriesOptions.grouping !== false) {\n                z = 0;\n            }\n            z += (seriesOptions.groupZPadding || 1);\n            for (const point of series.data) {\n                // #7103 Reset outside3dPlot flag\n                point.outside3dPlot = null;\n                if (point.y !== null) {\n                    const shapeArgs = extend({ x: 0, y: 0, width: 0, height: 0 }, point.shapeArgs || {}), \n                    // Array for final shapeArgs calculation.\n                    // We are checking two dimensions (x and y).\n                    dimensions = [['x', 'width'], ['y', 'height']], tooltipPos = point.tooltipPos;\n                    let borderlessBase; // Crisped rects can have +/- 0.5 pixels offset.\n                    // #3131 We need to check if column is inside plotArea.\n                    for (const d of dimensions) {\n                        borderlessBase = shapeArgs[d[0]] - borderCrisp;\n                        if (borderlessBase < 0) {\n                            // If borderLessBase is smaller than 0, it is needed to set\n                            // its value to 0 or 0.5 depending on borderWidth\n                            // borderWidth may be even or odd.\n                            shapeArgs[d[1]] += shapeArgs[d[0]] + borderCrisp;\n                            shapeArgs[d[0]] = -borderCrisp;\n                            borderlessBase = 0;\n                        }\n                        if ((borderlessBase + shapeArgs[d[1]] >\n                            series[d[0] + 'Axis'].len) &&\n                            // Do not change height/width of column if 0 (#6708)\n                            shapeArgs[d[1]] !== 0) {\n                            shapeArgs[d[1]] =\n                                series[d[0] + 'Axis'].len -\n                                    shapeArgs[d[0]];\n                        }\n                        if (\n                        // Do not remove columns with zero height/width.\n                        shapeArgs[d[1]] !== 0 &&\n                            (shapeArgs[d[0]] >= series[d[0] + 'Axis'].len ||\n                                shapeArgs[d[0]] + shapeArgs[d[1]] <= borderCrisp)) {\n                            // Set args to 0 if column is outside the chart.\n                            for (const key in shapeArgs) { // eslint-disable-line guard-for-in\n                                // #13840\n                                shapeArgs[key] = key === 'y' ? -9999 : 0;\n                            }\n                            // #7103 outside3dPlot flag is set on Points which are\n                            // currently outside of plot.\n                            point.outside3dPlot = true;\n                        }\n                    }\n                    // Change from 2d to 3d\n                    if (point.shapeType === 'roundedRect') {\n                        point.shapeType = 'cuboid';\n                    }\n                    point.shapeArgs = extend(shapeArgs, {\n                        z,\n                        depth,\n                        insidePlotArea: true\n                    });\n                    // Point's position in 2D\n                    point2dPos = {\n                        x: shapeArgs.x + shapeArgs.width / 2,\n                        y: shapeArgs.y,\n                        z: z + depth / 2 // The center of column in Z dimension\n                    };\n                    // Recalculate point positions for inverted graphs\n                    if (chart.inverted) {\n                        point2dPos.x = shapeArgs.height;\n                        point2dPos.y = point.clientX || 0;\n                    }\n                    // Calculate and store point's position in 3D,\n                    // using perspective method.\n                    point.plot3d = perspective([point2dPos], chart, true, false)[0];\n                    // Translate the tooltip position in 3d space\n                    if (tooltipPos) {\n                        const translatedTTPos = perspective([{\n                                x: tooltipPos[0],\n                                y: tooltipPos[1],\n                                z: z + depth / 2 // The center of column in Z dimension\n                            }], chart, true, false)[0];\n                        point.tooltipPos = [translatedTTPos.x, translatedTTPos.y];\n                    }\n                }\n            }\n            // store for later use #4067\n            series.z = z;\n        }\n        /** @private */\n        function compose(SeriesClass, StackItemClass) {\n            if (pushUnique(composedMembers, SeriesClass)) {\n                const seriesProto = SeriesClass.prototype;\n                wrap(seriesProto, 'alignDataLabel', wrapSeriesAlignDataLabel);\n                wrap(seriesProto, 'justifyDataLabel', wrapSeriesJustifyDataLabel);\n            }\n            if (pushUnique(composedMembers, StackItemClass)) {\n                const stackItemProto = StackItemClass.prototype;\n                wrap(stackItemProto, 'getStackBox', wrapStackItemGetStackBox);\n            }\n            const { column: ColumnSeriesClass, columnRange: ColumnRangeSeriesClass } = SeriesClass.types;\n            if (ColumnSeriesClass &&\n                pushUnique(composedMembers, ColumnSeriesClass)) {\n                const columnSeriesProto = ColumnSeriesClass.prototype, columnPointProto = columnSeriesProto.pointClass.prototype;\n                columnSeriesProto.translate3dPoints = () => void 0;\n                columnSeriesProto.translate3dShapes = columnSeriesTranslate3dShapes;\n                addEvent(columnSeriesProto, 'afterInit', onColumnSeriesAfterInit);\n                wrap(columnPointProto, 'hasNewShapeType', wrapColumnPointHasNewShapeType);\n                wrap(columnSeriesProto, 'animate', wrapColumnSeriesAnimate);\n                wrap(columnSeriesProto, 'plotGroup', wrapColumnSeriesPlotGroup);\n                wrap(columnSeriesProto, 'pointAttribs', wrapColumnSeriesPointAttribs);\n                wrap(columnSeriesProto, 'setState', wrapColumnSeriesSetState);\n                wrap(columnSeriesProto, 'setVisible', wrapColumnSeriesSetVisible);\n                wrap(columnSeriesProto, 'translate', wrapColumnSeriesTranslate);\n            }\n            if (ColumnRangeSeriesClass &&\n                pushUnique(composedMembers, ColumnRangeSeriesClass)) {\n                const columnRangeSeriesProto = ColumnRangeSeriesClass.prototype, columnRangePointProto = columnRangeSeriesProto.pointClass.prototype;\n                wrap(columnRangePointProto, 'hasNewShapeType', wrapColumnPointHasNewShapeType);\n                wrap(columnRangeSeriesProto, 'plotGroup', wrapColumnSeriesPlotGroup);\n                wrap(columnRangeSeriesProto, 'pointAttribs', wrapColumnSeriesPointAttribs);\n                wrap(columnRangeSeriesProto, 'setState', wrapColumnSeriesSetState);\n                wrap(columnRangeSeriesProto, 'setVisible', wrapColumnSeriesSetVisible);\n            }\n        }\n        /**\n         * @private\n         * @param {Highcharts.Chart} chart\n         * Chart with stacks\n         * @param {string} stacking\n         * Stacking option\n         */\n        function retrieveStacks(chart, stacking) {\n            const series = chart.series, stacks = { totalStacks: 0 };\n            let stackNumber, i = 1;\n            series.forEach(function (s) {\n                stackNumber = pick(s.options.stack, (stacking ? 0 : series.length - 1 - s.index)); // #3841, #4532\n                if (!stacks[stackNumber]) {\n                    stacks[stackNumber] = { series: [s], position: i };\n                    i++;\n                }\n                else {\n                    stacks[stackNumber].series.push(s);\n                }\n            });\n            stacks.totalStacks = i + 1;\n            return stacks;\n        }\n        /** @private */\n        function onColumnSeriesAfterInit() {\n            if (this.chart.is3d()) {\n                const series = this, seriesOptions = series.options, grouping = seriesOptions.grouping, stacking = seriesOptions.stacking, reversedStacks = series.yAxis.options.reversedStacks;\n                let z = 0;\n                // @todo grouping === true ?\n                if (!(typeof grouping !== 'undefined' && !grouping)) {\n                    const stacks = retrieveStacks(this.chart, stacking), stack = seriesOptions.stack || 0;\n                    let i; // position within the stack\n                    for (i = 0; i < stacks[stack].series.length; i++) {\n                        if (stacks[stack].series[i] === this) {\n                            break;\n                        }\n                    }\n                    z = (10 * (stacks.totalStacks - stacks[stack].position)) +\n                        (reversedStacks ? i : -i); // #4369\n                    // In case when axis is reversed, columns are also reversed inside\n                    // the group (#3737)\n                    if (!this.xAxis.reversed) {\n                        z = (stacks.totalStacks * 10) - z;\n                    }\n                }\n                seriesOptions.depth = seriesOptions.depth || 25;\n                series.z = series.z || 0;\n                seriesOptions.zIndex = z;\n            }\n        }\n        /**\n         * In 3D mode, simple checking for a new shape to animate is not enough.\n         * Additionally check if graphic is a group of elements\n         * @private\n         */\n        function wrapColumnPointHasNewShapeType(proceed, ...args) {\n            return this.series.chart.is3d() ?\n                this.graphic && this.graphic.element.nodeName !== 'g' :\n                proceed.apply(this, args);\n        }\n        /** @private */\n        function wrapColumnSeriesAnimate(proceed) {\n            if (!this.chart.is3d()) {\n                proceed.apply(this, [].slice.call(arguments, 1));\n            }\n            else {\n                const args = arguments, init = args[1], yAxis = this.yAxis, series = this, reversed = this.yAxis.reversed;\n                if (init) {\n                    for (const point of series.data) {\n                        if (point.y !== null) {\n                            point.height = point.shapeArgs.height;\n                            point.shapey = point.shapeArgs.y; // #2968\n                            point.shapeArgs.height = 1;\n                            if (!reversed) {\n                                if (point.stackY) {\n                                    point.shapeArgs.y =\n                                        point.plotY +\n                                            yAxis.translate(point.stackY);\n                                }\n                                else {\n                                    point.shapeArgs.y =\n                                        point.plotY +\n                                            (point.negative ?\n                                                -point.height :\n                                                point.height);\n                                }\n                            }\n                        }\n                    }\n                }\n                else { // run the animation\n                    for (const point of series.data) {\n                        if (point.y !== null) {\n                            point.shapeArgs.height = point.height;\n                            point.shapeArgs.y = point.shapey; // #2968\n                            // null value do not have a graphic\n                            if (point.graphic) {\n                                point.graphic[point.outside3dPlot ?\n                                    'attr' :\n                                    'animate'](point.shapeArgs, series.options.animation);\n                            }\n                        }\n                    }\n                    // redraw datalabels to the correct position\n                    this.drawDataLabels();\n                }\n            }\n        }\n        /**\n         * In case of 3d columns there is no sense to add these columns to a specific\n         * series group. If a series is added to a group all columns will have the same\n         * zIndex in comparison to another series.\n         * @private\n         */\n        function wrapColumnSeriesPlotGroup(proceed, prop, _name, _visibility, _zIndex, parent) {\n            if (prop !== 'dataLabelsGroup' && prop !== 'markerGroup') {\n                if (this.chart.is3d()) {\n                    if (this[prop]) {\n                        delete this[prop];\n                    }\n                    if (parent) {\n                        if (!this.chart.columnGroup) {\n                            this.chart.columnGroup =\n                                this.chart.renderer.g('columnGroup').add(parent);\n                        }\n                        this[prop] = this.chart.columnGroup;\n                        this.chart.columnGroup.attr(this.getPlotBox());\n                        this[prop].survive = true;\n                        if (prop === 'group') {\n                            arguments[3] = 'visible';\n                            // For 3D column group and markerGroup should be visible\n                        }\n                    }\n                }\n            }\n            return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        }\n        /** @private */\n        function wrapColumnSeriesPointAttribs(proceed) {\n            const attr = proceed.apply(this, [].slice.call(arguments, 1));\n            if (this.chart.is3d && this.chart.is3d()) {\n                // Set the fill color to the fill color to provide a smooth edge\n                attr.stroke = this.options.edgeColor || attr.fill;\n                attr['stroke-width'] = pick(this.options.edgeWidth, 1); // #4055\n            }\n            return attr;\n        }\n        /**\n         * In 3D mode, all column-series are rendered in one main group. Because of that\n         * we need to apply inactive state on all points.\n         * @private\n         */\n        function wrapColumnSeriesSetState(proceed, state, inherit) {\n            const is3d = this.chart.is3d && this.chart.is3d();\n            if (is3d) {\n                this.options.inactiveOtherPoints = true;\n            }\n            proceed.call(this, state, inherit);\n            if (is3d) {\n                this.options.inactiveOtherPoints = false;\n            }\n        }\n        /**\n         * When series is not added to group it is needed to change setVisible method to\n         * allow correct Legend funcionality. This wrap is basing on pie chart series.\n         * @private\n         */\n        function wrapColumnSeriesSetVisible(proceed, vis) {\n            const series = this;\n            if (series.chart.is3d()) {\n                for (const point of series.data) {\n                    point.visible = point.options.visible = vis =\n                        typeof vis === 'undefined' ?\n                            !pick(series.visible, point.visible) : vis;\n                    series.options.data[series.data.indexOf(point)] =\n                        point.options;\n                    if (point.graphic) {\n                        point.graphic.attr({\n                            visibility: vis ? 'visible' : 'hidden'\n                        });\n                    }\n                }\n            }\n            proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n        }\n        /** @private */\n        function wrapColumnSeriesTranslate(proceed) {\n            proceed.apply(this, [].slice.call(arguments, 1));\n            // Do not do this if the chart is not 3D\n            if (this.chart.is3d()) {\n                this.translate3dShapes();\n            }\n        }\n        /** @private */\n        function wrapSeriesAlignDataLabel(proceed, point, _dataLabel, options, alignTo) {\n            const chart = this.chart;\n            // In 3D we need to pass point.outsidePlot option to the justifyDataLabel\n            // method for disabling justifying dataLabels in columns outside plot\n            options.outside3dPlot = point.outside3dPlot;\n            // Only do this for 3D columns and it's derived series\n            if (chart.is3d() &&\n                this.is('column')) {\n                const series = this, seriesOptions = series.options, inside = pick(options.inside, !!series.options.stacking), options3d = chart.options.chart.options3d, xOffset = point.pointWidth / 2 || 0;\n                let dLPosition = {\n                    x: alignTo.x + xOffset,\n                    y: alignTo.y,\n                    z: series.z + seriesOptions.depth / 2\n                };\n                if (chart.inverted) {\n                    // Inside dataLabels are positioned according to above\n                    // logic and there is no need to position them using\n                    // non-3D algorighm (that use alignTo.width)\n                    if (inside) {\n                        alignTo.width = 0;\n                        dLPosition.x += point.shapeArgs.height / 2;\n                    }\n                    // When chart is upside down\n                    // (alpha angle between 180 and 360 degrees)\n                    // it is needed to add column width to calculated value.\n                    if (options3d.alpha >= 90 && options3d.alpha <= 270) {\n                        dLPosition.y += point.shapeArgs.width;\n                    }\n                }\n                // dLPosition is recalculated for 3D graphs\n                dLPosition = perspective([dLPosition], chart, true, false)[0];\n                alignTo.x = dLPosition.x - xOffset;\n                // #7103 If point is outside of plotArea, hide data label.\n                alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y;\n            }\n            proceed.apply(this, [].slice.call(arguments, 1));\n        }\n        /**\n         * Don't use justifyDataLabel when point is outsidePlot.\n         * @private\n         */\n        function wrapSeriesJustifyDataLabel(proceed) {\n            return (!(arguments[2].outside3dPlot) ?\n                proceed.apply(this, [].slice.call(arguments, 1)) :\n                false);\n        }\n        /**\n         * Added stackLabels position calculation for 3D charts.\n         * @private\n         */\n        function wrapStackItemGetStackBox(proceed, stackBoxProps) {\n            const stackBox = proceed.apply(this, [].slice.call(arguments, 1));\n            // Only do this for 3D graph\n            const stackItem = this, chart = this.axis.chart, { width: xWidth } = stackBoxProps;\n            if (chart.is3d() && stackItem.base) {\n                // First element of stackItem.base is an index of base series.\n                const baseSeriesInd = +(stackItem.base).split(',')[0];\n                const columnSeries = chart.series[baseSeriesInd];\n                const options3d = chart.options.chart.options3d;\n                // Only do this if base series is a column or inherited type,\n                // use its barW, z and depth parameters\n                // for correct stackLabels position calculation\n                if (columnSeries &&\n                    columnSeries.type === 'column') {\n                    let dLPosition = {\n                        x: stackBox.x + (chart.inverted ? stackBox.height : xWidth / 2),\n                        y: stackBox.y,\n                        z: columnSeries.options.depth / 2\n                    };\n                    if (chart.inverted) {\n                        // Do not use default offset calculation logic\n                        // for 3D inverted stackLabels.\n                        stackBox.width = 0;\n                        // When chart is upside down\n                        // (alpha angle between 180 and 360 degrees)\n                        // it is needed to add column width to calculated value.\n                        if (options3d.alpha >= 90 && options3d.alpha <= 270) {\n                            dLPosition.y += xWidth;\n                        }\n                    }\n                    dLPosition = perspective([dLPosition], chart, true, false)[0];\n                    stackBox.x = dLPosition.x - xWidth / 2;\n                    stackBox.y = dLPosition.y;\n                }\n            }\n            return stackBox;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const Column3DComposition = {\n            compose\n        };\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Depth of the columns in a 3D column chart.\n         *\n         * @type      {number}\n         * @default   25\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.depth\n         */\n        /**\n         * 3D columns only. The color of the edges. Similar to `borderColor`, except it\n         * defaults to the same color as the column.\n         *\n         * @type      {Highcharts.ColorString}\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.edgeColor\n         */\n        /**\n         * 3D columns only. The width of the colored edges.\n         *\n         * @type      {number}\n         * @default   1\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.edgeWidth\n         */\n        /**\n         * The spacing between columns on the Z Axis in a 3D chart.\n         *\n         * @type      {number}\n         * @default   1\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.column.groupZPadding\n         */\n        ''; // keeps doclets above in transpiled file\n\n        return Column3DComposition;\n    });\n    _registerModule(_modules, 'Series/Pie3D/Pie3DPoint.js', [_modules['Core/Series/SeriesRegistry.js']], function (SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  3D pie series\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pie: { prototype: { pointClass: PiePoint } } } = SeriesRegistry.seriesTypes;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class Pie3DPoint extends PiePoint {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.series = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            haloPath() {\n                return this.series?.chart.is3d() ?\n                    [] : super.haloPath.apply(this, arguments);\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Pie3DPoint;\n    });\n    _registerModule(_modules, 'Series/Pie3D/Pie3DSeries.js', [_modules['Core/Globals.js'], _modules['Series/Pie3D/Pie3DPoint.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (H, Pie3DPoint, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  3D pie series\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { deg2rad } = H;\n        const { pie: PieSeries } = SeriesRegistry.seriesTypes;\n        const { extend, pick, pushUnique } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedMembers = [];\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class Pie3DSeries extends PieSeries {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static compose(SeriesClass) {\n                if (pushUnique(composedMembers, SeriesClass)) {\n                    SeriesClass.types.pie = Pie3DSeries;\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            addPoint() {\n                super.addPoint.apply(this, arguments);\n                if (this.chart.is3d()) {\n                    // destroy (and rebuild) everything!!!\n                    this.update(this.userOptions, true); // #3845 pass the old options\n                }\n            }\n            /**\n             * @private\n             */\n            animate(init) {\n                if (!this.chart.is3d()) {\n                    super.animate.apply(this, arguments);\n                }\n                else {\n                    const center = this.center, group = this.group, markerGroup = this.markerGroup;\n                    let animation = this.options.animation, attribs;\n                    if (animation === true) {\n                        animation = {};\n                    }\n                    // Initialize the animation\n                    if (init) {\n                        // Scale down the group and place it in the center\n                        group.oldtranslateX = pick(group.oldtranslateX, group.translateX);\n                        group.oldtranslateY = pick(group.oldtranslateY, group.translateY);\n                        attribs = {\n                            translateX: center[0],\n                            translateY: center[1],\n                            scaleX: 0.001,\n                            scaleY: 0.001\n                        };\n                        group.attr(attribs);\n                        if (markerGroup) {\n                            markerGroup.attrSetters = group.attrSetters;\n                            markerGroup.attr(attribs);\n                        }\n                        // Run the animation\n                    }\n                    else {\n                        attribs = {\n                            translateX: group.oldtranslateX,\n                            translateY: group.oldtranslateY,\n                            scaleX: 1,\n                            scaleY: 1\n                        };\n                        group.animate(attribs, animation);\n                        if (markerGroup) {\n                            markerGroup.animate(attribs, animation);\n                        }\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            getDataLabelPosition(point, distance) {\n                const labelPosition = super.getDataLabelPosition(point, distance);\n                if (this.chart.is3d()) {\n                    const options3d = this.chart.options.chart.options3d, shapeArgs = point.shapeArgs, r = shapeArgs.r, \n                    // #3240 issue with datalabels for 0 and null values\n                    a1 = ((shapeArgs.alpha || options3d?.alpha) *\n                        deg2rad), b1 = ((shapeArgs.beta || options3d?.beta) *\n                        deg2rad), a2 = (shapeArgs.start + shapeArgs.end) / 2, connectorPosition = labelPosition.connectorPosition, yOffset = (-r * (1 - Math.cos(a1)) * Math.sin(a2)), xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);\n                    // Apply perspective on label positions\n                    for (const coordinates of [\n                        labelPosition?.natural,\n                        connectorPosition.breakAt,\n                        connectorPosition.touchingSliceAt\n                    ]) {\n                        coordinates.x += xOffset;\n                        coordinates.y += yOffset;\n                    }\n                }\n                return labelPosition;\n            }\n            /**\n             * @private\n             */\n            pointAttribs(point) {\n                const attr = super.pointAttribs.apply(this, arguments), options = this.options;\n                if (this.chart.is3d() && !this.chart.styledMode) {\n                    attr.stroke = options.edgeColor || point.color || this.color;\n                    attr['stroke-width'] = pick(options.edgeWidth, 1);\n                }\n                return attr;\n            }\n            /**\n             * @private\n             */\n            translate() {\n                super.translate.apply(this, arguments);\n                // Do not do this if the chart is not 3D\n                if (!this.chart.is3d()) {\n                    return;\n                }\n                const series = this, seriesOptions = series.options, depth = seriesOptions.depth || 0, options3d = series.chart.options.chart.options3d, alpha = options3d.alpha, beta = options3d.beta;\n                let z = seriesOptions.stacking ?\n                    (seriesOptions.stack || 0) * depth :\n                    series._i * depth;\n                z += depth / 2;\n                if (seriesOptions.grouping !== false) {\n                    z = 0;\n                }\n                for (const point of series.data) {\n                    const shapeArgs = point.shapeArgs;\n                    point.shapeType = 'arc3d';\n                    shapeArgs.z = z;\n                    shapeArgs.depth = depth * 0.75;\n                    shapeArgs.alpha = alpha;\n                    shapeArgs.beta = beta;\n                    shapeArgs.center = series.center;\n                    const angle = (shapeArgs.end + shapeArgs.start) / 2;\n                    point.slicedTranslation = {\n                        translateX: Math.round(Math.cos(angle) *\n                            seriesOptions.slicedOffset *\n                            Math.cos(alpha * deg2rad)),\n                        translateY: Math.round(Math.sin(angle) *\n                            seriesOptions.slicedOffset *\n                            Math.cos(alpha * deg2rad))\n                    };\n                }\n            }\n            /**\n             * @private\n             */\n            drawTracker() {\n                super.drawTracker.apply(this, arguments);\n                // Do not do this if the chart is not 3D\n                if (!this.chart.is3d()) {\n                    return;\n                }\n                for (const point of this.points) {\n                    if (point.graphic) {\n                        for (const face of ['out', 'inn', 'side1', 'side2']) {\n                            if (point.graphic) {\n                                point.graphic[face].element.point = point;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        extend(Pie3DSeries.prototype, {\n            pointClass: Pie3DPoint\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The thickness of a 3D pie.\n         *\n         * @type      {number}\n         * @default   0\n         * @since     4.0\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption plotOptions.pie.depth\n         */\n        ''; // keeps doclets above after transpilation\n\n        return Pie3DSeries;\n    });\n    _registerModule(_modules, 'Series/Scatter3D/Scatter3DPoint.js', [_modules['Series/Scatter/ScatterSeries.js'], _modules['Core/Utilities.js']], function (ScatterSeries, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Scatter 3D series.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pointClass: ScatterPoint } = ScatterSeries.prototype;\n        const { defined } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        class Scatter3DPoint extends ScatterPoint {\n            constructor() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                super(...arguments);\n                this.options = void 0;\n                this.series = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            applyOptions() {\n                super.applyOptions.apply(this, arguments);\n                if (!defined(this.z)) {\n                    this.z = 0;\n                }\n                return this;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Scatter3DPoint;\n    });\n    _registerModule(_modules, 'Series/Scatter3D/Scatter3DSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Scatter 3D series.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A 3D scatter plot uses x, y and z coordinates to display values for three\n         * variables for a set of data.\n         *\n         * @sample {highcharts} highcharts/3d/scatter/\n         *         Simple 3D scatter\n         * @sample {highcharts} highcharts/demo/3d-scatter-draggable\n         *         Draggable 3d scatter\n         *\n         * @extends      plotOptions.scatter\n         * @excluding    dragDrop, cluster, boostThreshold, boostBlending\n         * @product      highcharts\n         * @requires     highcharts-3d\n         * @optionparent plotOptions.scatter3d\n         */\n        const Scatter3DSeriesDefaults = {\n            tooltip: {\n                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>'\n            }\n        };\n        /**\n         * A `scatter3d` series. If the [type](#series.scatter3d.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * scatter3d](#plotOptions.scatter3d).\n         *\n         * @extends   series,plotOptions.scatter3d\n         * @excluding boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-3d\n         * @apioption series.scatter3d\n         */\n        /**\n         * An array of data points for the series. For the `scatter3d` series\n         * type, points can be given in the following ways:\n         *\n         * 1.  An array of arrays with 3 values. In this case, the values correspond\n         * to `x,y,z`. If the first value is a string, it is applied as the name\n         * of the point, and the `x` value is inferred.\n         *\n         *  ```js\n         *     data: [\n         *         [0, 0, 1],\n         *         [1, 8, 7],\n         *         [2, 9, 2]\n         *     ]\n         *  ```\n         *\n         * 3.  An array of objects with named values. The following snippet shows only a\n         * few settings, see the complete options set below. If the total number of data\n         * points exceeds the series'\n         * [turboThreshold](#series.scatter3d.turboThreshold), this option is not\n         * available.\n         *\n         *  ```js\n         *     data: [{\n         *         x: 1,\n         *         y: 2,\n         *         z: 24,\n         *         name: \"Point2\",\n         *         color: \"#00FF00\"\n         *     }, {\n         *         x: 1,\n         *         y: 4,\n         *         z: 12,\n         *         name: \"Point1\",\n         *         color: \"#FF00FF\"\n         *     }]\n         *  ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<number>|*>}\n         * @extends   series.scatter.data\n         * @product   highcharts\n         * @apioption series.scatter3d.data\n         */\n        /**\n         * The z value for each data point.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.scatter3d.data.z\n         */\n        ''; // detachs doclets above\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Scatter3DSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Scatter3D/Scatter3DSeries.js', [_modules['Core/Math3D.js'], _modules['Series/Scatter3D/Scatter3DPoint.js'], _modules['Series/Scatter3D/Scatter3DSeriesDefaults.js'], _modules['Series/Scatter/ScatterSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Math3D, Scatter3DPoint, Scatter3DSeriesDefaults, ScatterSeries, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  Scatter 3D series.\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pointCameraDistance } = Math3D;\n        const { extend, merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.scatter3d\n         *\n         * @augments Highcharts.Series\n         */\n        class Scatter3DSeries extends ScatterSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            pointAttribs(point) {\n                const attribs = super.pointAttribs.apply(this, arguments);\n                if (this.chart.is3d() && point) {\n                    attribs.zIndex =\n                        pointCameraDistance(point, this.chart);\n                }\n                return attribs;\n            }\n        }\n        Scatter3DSeries.defaultOptions = merge(ScatterSeries.defaultOptions, Scatter3DSeriesDefaults);\n        extend(Scatter3DSeries.prototype, {\n            axisTypes: ['xAxis', 'yAxis', 'zAxis'],\n            // Require direct touch rather than using the k-d-tree, because the\n            // k-d-tree currently doesn't take the xyz coordinate system into\n            // account (#4552)\n            directTouch: true,\n            parallelArrays: ['x', 'y', 'z'],\n            pointArrayMap: ['x', 'y', 'z'],\n            pointClass: Scatter3DPoint\n        });\n        SeriesRegistry.registerSeriesType('scatter3d', Scatter3DSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Scatter3DSeries;\n    });\n    _registerModule(_modules, 'masters/highcharts-3d.src.js', [_modules['Core/Globals.js'], _modules['Core/Chart/Chart3D.js'], _modules['Series/Area3D/Area3DSeries.js'], _modules['Core/Axis/Axis3DComposition.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Series/Series3D.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Renderer/SVG/SVGRenderer3D.js'], _modules['Core/Axis/ZAxis.js'], _modules['Series/Column3D/Column3DComposition.js'], _modules['Series/Pie3D/Pie3DSeries.js']], function (Highcharts, Chart3D, Area3DSeries, Axis3DComposition, RendererRegistry, Series3D, StackItem, SVGRenderer3D, ZAxis, Column3DComposition, Pie3DSeries) {\n\n        const G = Highcharts;\n        // Compositions\n        Area3DSeries.compose(G.seriesTypes.area);\n        Axis3DComposition.compose(G.Axis, G.Tick);\n        Chart3D.compose(G.Chart, G.Fx);\n        Column3DComposition.compose(G.Series, StackItem);\n        Pie3DSeries.compose(G.Series);\n        Series3D.compose(G.Series);\n        SVGRenderer3D.compose(RendererRegistry.getRendererType());\n        ZAxis.compose(G.Chart);\n\n    });\n}));"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}